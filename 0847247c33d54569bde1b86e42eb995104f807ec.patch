From 0847247c33d54569bde1b86e42eb995104f807ec Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Vuka=C5=A1in=20Vojinovi=C4=87?=
 <150025636+git-f0x@users.noreply.github.com>
Date: Thu, 16 Oct 2025 13:50:32 +0200
Subject: [PATCH] chore: clippy

---
 build.rs                                      |   5 +-
 src/backend/kms/device.rs                     |  28 ++-
 src/backend/kms/drm_helpers.rs                |   2 +-
 src/backend/kms/mod.rs                        |  28 ++-
 src/backend/kms/render/pixman.rs              |   6 +
 src/backend/kms/surface/mod.rs                |  37 ++--
 src/backend/kms/surface/timings.rs            |   3 +-
 src/backend/mod.rs                            |   2 +-
 src/backend/render/cursor.rs                  |   6 +-
 src/backend/render/element.rs                 |   4 +-
 src/backend/render/mod.rs                     |  36 ++--
 src/backend/winit.rs                          |   2 +-
 src/backend/x11.rs                            |  37 ++--
 src/config/input_config.rs                    |   6 +-
 src/config/mod.rs                             |  16 +-
 src/dbus/mod.rs                               |   8 +-
 src/input/actions.rs                          |  25 ++-
 src/input/gestures/mod.rs                     |   8 +-
 src/input/mod.rs                              | 140 ++++++------
 src/main.rs                                   |   7 +-
 src/session.rs                                |   4 +-
 src/shell/element/mod.rs                      |  44 ++--
 src/shell/element/stack.rs                    |  23 +-
 src/shell/element/stack/tab.rs                |   2 +-
 src/shell/element/stack/tabs.rs               |   4 +-
 src/shell/element/surface.rs                  |  13 +-
 src/shell/element/window.rs                   |  18 +-
 src/shell/focus/mod.rs                        | 115 +++++-----
 src/shell/focus/order.rs                      |  20 +-
 src/shell/focus/target.rs                     |   8 +-
 src/shell/grabs/menu/default.rs               |  12 +-
 src/shell/grabs/menu/item.rs                  |   8 +-
 src/shell/grabs/menu/mod.rs                   |  15 +-
 src/shell/grabs/mod.rs                        |   6 +-
 src/shell/grabs/moving.rs                     |  24 +--
 src/shell/layout/floating/grabs/resize.rs     |  46 ++--
 src/shell/layout/floating/mod.rs              |  36 ++--
 src/shell/layout/tiling/grabs/resize.rs       |   6 +-
 src/shell/layout/tiling/grabs/swap.rs         |   2 +-
 src/shell/layout/tiling/mod.rs                | 202 ++++++++----------
 src/shell/mod.rs                              | 177 +++++++--------
 src/shell/seats.rs                            |   8 +-
 src/shell/workspace.rs                        |  34 ++-
 src/shell/zoom.rs                             |  40 ++--
 src/state.rs                                  | 112 +++++-----
 src/systemd.rs                                |   4 +-
 src/utils/env.rs                              |   9 +-
 src/utils/iced.rs                             |  22 +-
 src/utils/prelude.rs                          |   7 +-
 src/utils/screenshot.rs                       |   4 +-
 src/wayland/handlers/atspi.rs                 |   6 +-
 src/wayland/handlers/buffer.rs                |  15 +-
 src/wayland/handlers/compositor.rs            |  10 +-
 src/wayland/handlers/data_device.rs           |   2 +-
 src/wayland/handlers/decoration.rs            |  14 +-
 src/wayland/handlers/output_power.rs          |   2 +-
 src/wayland/handlers/pointer_constraints.rs   |   3 +-
 src/wayland/handlers/screencopy/mod.rs        |   6 +-
 src/wayland/handlers/screencopy/render.rs     |  10 +-
 src/wayland/handlers/security_context.rs      |   4 +-
 src/wayland/handlers/session_lock.rs          |   4 +-
 src/wayland/handlers/toplevel_management.rs   |   8 +-
 src/wayland/handlers/xdg_activation.rs        |   4 +-
 src/wayland/handlers/xdg_shell/mod.rs         |  16 +-
 src/wayland/handlers/xdg_shell/popup.rs       |   6 +-
 src/wayland/protocols/corner_radius.rs        |   5 +-
 src/wayland/protocols/drm.rs                  |   4 +-
 src/wayland/protocols/image_capture_source.rs |  51 ++---
 .../output_configuration/handlers/cosmic.rs   |  21 +-
 .../output_configuration/handlers/wlr.rs      |  34 ++-
 .../protocols/output_configuration/mod.rs     |   9 +-
 src/wayland/protocols/overlap_notify.rs       |  33 ++-
 src/wayland/protocols/screencopy.rs           | 139 ++++++------
 src/wayland/protocols/toplevel_info.rs        |  21 +-
 src/wayland/protocols/workspace/ext.rs        |   4 +-
 src/wayland/protocols/workspace/mod.rs        |   8 +-
 src/xwayland.rs                               |  32 ++-
 77 files changed, 869 insertions(+), 1033 deletions(-)

diff --git a/build.rs b/build.rs
index 9a5d56f7d..a8f895beb 100644
--- a/build.rs
+++ b/build.rs
@@ -2,10 +2,9 @@
 use std::process::Command;
 
 fn main() {
-    if let Some(output) = Command::new("git")
-        .args(&["rev-parse", "HEAD"])
+    if let Ok(output) = Command::new("git")
+        .args(["rev-parse", "HEAD"])
         .output()
-        .ok()
     {
         let git_hash = String::from_utf8(output.stdout).unwrap();
         println!("cargo:rustc-env=GIT_HASH={}", git_hash);
diff --git a/src/backend/kms/device.rs b/src/backend/kms/device.rs
index 13492417c..989137982 100644
--- a/src/backend/kms/device.rs
+++ b/src/backend/kms/device.rs
@@ -186,8 +186,7 @@ impl State {
             if let Ok(node) = DrmNode::from_dev_id(dev) {
                 let node = node
                     .node_with_type(NodeType::Render)
-                    .map(|res| res.ok())
-                    .flatten()
+                    .and_then(|res| res.ok())
                     .unwrap_or(node);
                 for ident in allowlist {
                     if ident.matches(&node) {
@@ -208,8 +207,7 @@ impl State {
             if let Ok(node) = DrmNode::from_dev_id(dev) {
                 let node = node
                     .node_with_type(NodeType::Render)
-                    .map(|res| res.ok())
-                    .flatten()
+                    .and_then(|res| res.ok())
                     .unwrap_or(node);
                 for ident in blocklist {
                     if ident.matches(&node) {
@@ -228,7 +226,7 @@ impl State {
                 .kms()
                 .session
                 .open(
-                    &path,
+                    path,
                     OFlags::RDWR | OFlags::CLOEXEC | OFlags::NOCTTY | OFlags::NONBLOCK,
                 )
                 .with_context(|| {
@@ -595,7 +593,7 @@ impl Device {
 
         let added = config
             .iter()
-            .filter(|(conn, maybe)| match (surfaces.get(&conn), maybe) {
+            .filter(|(conn, maybe)| match (surfaces.get(conn), maybe) {
                 (Some(current_crtc), Some(new_crtc)) => current_crtc != new_crtc,
                 // see `removed`
                 (Some(_), None) => true,
@@ -610,10 +608,10 @@ impl Device {
             .outputs
             .iter()
             .filter(|(conn, _)| match config.get(conn) {
-                Some(Some(c)) => surfaces.get(&conn).is_some_and(|crtc| c != crtc),
+                Some(Some(c)) => surfaces.get(conn).is_some_and(|crtc| c != crtc),
                 // if don't have a crtc, we need to drop the surface if it exists.
                 // so it needs to be in both `removed` AND `added`.
-                Some(None) => surfaces.get(&conn).is_some(),
+                Some(None) => surfaces.get(conn).is_some(),
                 _ => true,
             })
             .map(|(conn, _)| *conn)
@@ -630,7 +628,7 @@ impl Device {
     }
 }
 
-impl<'a> LockedDevice<'a> {
+impl LockedDevice<'_> {
     fn allow_frame_flags(
         &mut self,
         flag: bool,
@@ -660,7 +658,7 @@ impl<'a> LockedDevice<'a> {
                         renderer,
                         shell,
                         now,
-                        &output,
+                        output,
                         CursorMode::All,
                         None,
                     )
@@ -759,7 +757,7 @@ impl InnerDevice {
             .outputs
             .get(&conn)
             .cloned()
-            .map(|output| Ok(output))
+            .map(Ok)
             .unwrap_or_else(|| create_output_for_conn(drm, conn))
             .context("Failed to create `Output`")?;
 
@@ -895,7 +893,7 @@ impl InnerDevice {
     {
         for surface in self.surfaces.values_mut() {
             let known_nodes = surface.known_nodes().clone();
-            for gone_device in known_nodes.difference(&used_devices) {
+            for gone_device in known_nodes.difference(used_devices) {
                 surface.remove_node(*gone_device);
             }
             for new_device in used_devices.difference(&known_nodes) {
@@ -993,7 +991,7 @@ fn populate_modes(
         .iter()
         .find(|mode| mode.mode_type().contains(ModeTypeFlags::PREFERRED))
         .copied()
-        .or(conn_info.modes().get(0).copied())
+        .or(conn_info.modes().first().copied())
     else {
         anyhow::bail!("No mode found");
     };
@@ -1011,13 +1009,13 @@ fn populate_modes(
             size: (mode.size().0 as i32, mode.size().1 as i32).into(),
             refresh: refresh_rate as i32,
         };
-        modes.push(mode.clone());
+        modes.push(mode);
         output.add_mode(mode);
     }
     for mode in output
         .modes()
         .into_iter()
-        .filter(|mode| !modes.contains(&mode))
+        .filter(|mode| !modes.contains(mode))
     {
         output.delete_mode(mode);
     }
diff --git a/src/backend/kms/drm_helpers.rs b/src/backend/kms/drm_helpers.rs
index 2c4f3d4fc..7633d588b 100644
--- a/src/backend/kms/drm_helpers.rs
+++ b/src/backend/kms/drm_helpers.rs
@@ -82,7 +82,7 @@ pub fn display_configuration(
             .flat_map(|conn| device.get_connector(*conn, false).ok())
             .filter(|conn| {
                 if let Some(enc) = conn.current_encoder() {
-                    if let Some(enc) = device.get_encoder(enc).ok() {
+                    if let Ok(enc) = device.get_encoder(enc) {
                         if let Some(crtc) = enc.crtc() {
                             return cleanup.contains(&crtc);
                         }
diff --git a/src/backend/kms/mod.rs b/src/backend/kms/mod.rs
index 5a591cffe..1b01600ee 100644
--- a/src/backend/kms/mod.rs
+++ b/src/backend/kms/mod.rs
@@ -135,7 +135,7 @@ pub fn init_backend(
     // manually add already present gpus
     let mut outputs = Vec::new();
     for (dev, path) in udev_dispatcher.as_source_ref().device_list() {
-        match state.device_added(dev, path.into(), dh) {
+        match state.device_added(dev, path, dh) {
             Ok(added) => outputs.extend(added),
             Err(err) => warn!("Failed to add device {}: {:?}", path.display(), err),
         }
@@ -169,7 +169,7 @@ pub fn init_backend(
     }
 
     // start x11
-    let primary = state.backend.kms().primary_node.read().unwrap().clone();
+    let primary = *state.backend.kms().primary_node.read().unwrap();
     state.launch_xwayland(primary);
 
     Ok(())
@@ -209,7 +209,7 @@ fn init_libinput(
     .context("Failed to initialize libinput event source")?;
 
     // Create relative pointer global
-    RelativePointerManagerState::new::<State>(&dh);
+    RelativePointerManagerState::new::<State>(dh);
 
     Ok(libinput_context)
 }
@@ -239,7 +239,7 @@ fn determine_primary_gpu(
     // try to find builtin display
     for dev in drm_devices.values() {
         if dev.inner.surfaces.values().any(|s| {
-            if let Some(conn_info) = dev.drm.device().get_connector(s.connector, false).ok() {
+            if let Ok(conn_info) = dev.drm.device().get_connector(s.connector, false) {
                 let i = conn_info.interface();
                 i == Interface::EmbeddedDisplayPort || i == Interface::LVDS || i == Interface::DSI
             } else {
@@ -392,7 +392,7 @@ impl State {
                     }
                 } else {
                     let dh = state.common.display_handle.clone();
-                    match state.device_added(dev, path.into(), &dh) {
+                    match state.device_added(dev, path, &dh) {
                         Ok(outputs) => added.extend(outputs),
                         Err(err) => error!(?err, "Failed to add drm device {}.", path.display(),),
                     }
@@ -465,7 +465,7 @@ impl KmsState {
                         if let Some(state) = self.syncobj_state.as_mut() {
                             state.update_device(import_device);
                         } else {
-                            let syncobj_state = DrmSyncobjState::new::<State>(&dh, import_device);
+                            let syncobj_state = DrmSyncobjState::new::<State>(dh, import_device);
                             self.syncobj_state = Some(syncobj_state);
                         }
                         return Ok(());
@@ -646,7 +646,7 @@ impl KmsState {
     }
 }
 
-impl<'a> KmsGuard<'a> {
+impl KmsGuard<'_> {
     pub fn schedule_render(&mut self, output: &Output) {
         for surface in self
             .drm_devices
@@ -755,7 +755,7 @@ impl<'a> KmsGuard<'a> {
                 .crtcs()
                 .iter()
                 .filter(|crtc| {
-                    !device.inner.surfaces.get(crtc).is_some()
+                    device.inner.surfaces.get(crtc).is_none()
                     // TODO: We can't do this. See https://github.com/Smithay/smithay/pull/1820
                     //.is_some_and(|surface| surface.output.is_enabled())
                 })
@@ -915,7 +915,7 @@ impl<'a> KmsGuard<'a> {
                                     &mut renderer,
                                     &shell,
                                     now,
-                                    &output,
+                                    output,
                                     CursorMode::All,
                                     None,
                                 )
@@ -1024,7 +1024,7 @@ impl<'a> KmsGuard<'a> {
                                 &mut renderer,
                                 &shell,
                                 now,
-                                &output,
+                                output,
                                 CursorMode::All,
                                 None,
                             )
@@ -1068,7 +1068,7 @@ impl<'a> KmsGuard<'a> {
                         &mut renderer,
                         &shell,
                         now,
-                        &output,
+                        output,
                         CursorMode::All,
                         None,
                     )
@@ -1103,10 +1103,8 @@ impl<'a> KmsGuard<'a> {
                         None
                     };
 
-                if !test_only {
-                    if mirrored_output != surface.output.mirroring() {
-                        surface.set_mirroring(mirrored_output.clone());
-                    }
+                if !test_only && mirrored_output != surface.output.mirroring() {
+                    surface.set_mirroring(mirrored_output.clone());
                 }
             }
         }
diff --git a/src/backend/kms/render/pixman.rs b/src/backend/kms/render/pixman.rs
index 70764f200..27cc67323 100644
--- a/src/backend/kms/render/pixman.rs
+++ b/src/backend/kms/render/pixman.rs
@@ -42,6 +42,12 @@ impl fmt::Debug for GbmPixmanDevice {
     }
 }
 
+impl<A: AsFd + 'static> Default for GbmPixmanBackend<A> {
+    fn default() -> Self {
+        Self::new()
+    }
+}
+
 impl<A: AsFd + 'static> GbmPixmanBackend<A> {
     pub fn new() -> Self {
         GbmPixmanBackend {
diff --git a/src/backend/kms/surface/mod.rs b/src/backend/kms/surface/mod.rs
index 3c20a4b6a..464992e58 100644
--- a/src/backend/kms/surface/mod.rs
+++ b/src/backend/kms/surface/mod.rs
@@ -181,15 +181,14 @@ pub type GbmDrmOutput = DrmOutput<
     DrmDeviceFd,
 >;
 
-#[derive(Debug)]
+#[derive(Debug, Default)]
 pub enum QueueState {
+    #[default]
     Idle,
     /// A redraw is queued.
     Queued(RegistrationToken),
     /// We submitted a frame to the KMS and waiting for it to be presented.
-    WaitingForVBlank {
-        redraw_needed: bool,
-    },
+    WaitingForVBlank { redraw_needed: bool },
     /// We did not submit anything to KMS and made a timer to fire at the estimated VBlank.
     WaitingForEstimatedVBlank(RegistrationToken),
     /// A redraw is queued on top of the above.
@@ -199,12 +198,6 @@ pub enum QueueState {
     },
 }
 
-impl Default for QueueState {
-    fn default() -> Self {
-        QueueState::Idle
-    }
-}
-
 #[derive(Debug)]
 pub enum ThreadCommand {
     Suspend(SyncSender<()>),
@@ -760,7 +753,7 @@ impl SurfaceThreadState {
 
         let now = self.clock.now();
         let presentation_time = match metadata.as_ref().map(|data| &data.time) {
-            Some(DrmEventTime::Monotonic(tp)) => Some(tp.clone()),
+            Some(DrmEventTime::Monotonic(tp)) => Some(*tp),
             _ => None,
         };
         let sequence = metadata.as_ref().map(|data| data.sequence).unwrap_or(0);
@@ -944,7 +937,7 @@ impl SurfaceThreadState {
                     warn!(?name, "Failed to submit rendering: {:?}", err);
                     state.queue_redraw(true);
                 }
-                return TimeoutAction::Drop;
+                TimeoutAction::Drop
             })
             .expect("Failed to schedule render");
 
@@ -954,7 +947,7 @@ impl SurfaceThreadState {
             }
             QueueState::WaitingForEstimatedVBlank(estimated_vblank) => {
                 self.state = QueueState::WaitingForEstimatedVBlankAndQueued {
-                    estimated_vblank: estimated_vblank.clone(),
+                    estimated_vblank: *estimated_vblank,
                     queued_render: token,
                 };
             }
@@ -968,7 +961,7 @@ impl SurfaceThreadState {
             } if force => {
                 self.loop_handle.remove(*queued_render);
                 self.state = QueueState::WaitingForEstimatedVBlankAndQueued {
-                    estimated_vblank: estimated_vblank.clone(),
+                    estimated_vblank: *estimated_vblank,
                     queued_render: token,
                 };
             }
@@ -990,7 +983,7 @@ impl SurfaceThreadState {
                 .as_ref()
                 .unwrap_or(&self.target_node),
             &self.target_node,
-            &*self.shell.read(),
+            &self.shell.read(),
         );
 
         let mut renderer = if render_node != self.target_node {
@@ -1016,7 +1009,7 @@ impl SurfaceThreadState {
                     (
                         true,
                         fullscreen_surface.wl_surface().is_some_and(|surface| {
-                            recursive_frame_time_estimation(&self.clock, &*surface)
+                            recursive_frame_time_estimation(&self.clock, &surface)
                                 .is_some_and(|dur| dur <= _30_FPS)
                         }),
                         animations_going,
@@ -1079,7 +1072,7 @@ impl SurfaceThreadState {
         let source_output = self
             .mirroring
             .as_ref()
-            .or((!self.screen_filter.is_noop()).then(|| &self.output))
+            .or((!self.screen_filter.is_noop()).then_some(&self.output))
             .filter(|output| {
                 PostprocessOutputConfig::for_output_untransformed(output)
                     != PostprocessOutputConfig::for_output(&self.output)
@@ -1258,7 +1251,7 @@ impl SurfaceThreadState {
                 &mut renderer,
                 &self.output,
                 &pre_postprocess_data,
-                &postprocess_state,
+                postprocess_state,
                 &self.screen_filter,
             );
 
@@ -1507,7 +1500,7 @@ fn render_node_for_output(
         .flat_map(|w| w.wl_surface().and_then(|s| source_node_for_surface(&s)))
         .collect::<Vec<_>>();
 
-    if nodes.contains(&target_node) || nodes.is_empty() {
+    if nodes.contains(target_node) || nodes.is_empty() {
         *target_node
     } else {
         *primary_node
@@ -1575,7 +1568,7 @@ fn get_surface_dmabuf_feedback(
                 FormatSet::from_iter(
                     primary_plane_formats
                         .into_iter()
-                        .chain(overlay_plane_formats.into_iter()),
+                        .chain(overlay_plane_formats),
                 ),
             )
             .build()
@@ -1648,7 +1641,7 @@ fn take_screencopy_frames(
             } else {
                 damage_tracking.age_for_buffer(&buffer)
             };
-            let res = damage_tracking.dt.damage_output(age, &elements);
+            let res = damage_tracking.dt.damage_output(age, elements);
 
             if let Some(old_len) = old_len {
                 elements.truncate(old_len);
@@ -1708,7 +1701,7 @@ fn send_screencopy_result<'a>(
             .texture
             .as_ref()
             .is_some_and(|tex| tex.format() == Some(format))
-            && (session.draw_cursor() == false || pre_postprocess_data.cursor_texture.is_none())
+            && (!session.draw_cursor() || pre_postprocess_data.cursor_texture.is_none())
         {
             None
         } else {
diff --git a/src/backend/kms/surface/timings.rs b/src/backend/kms/surface/timings.rs
index 11ea510ff..06dca0f96 100644
--- a/src/backend/kms/surface/timings.rs
+++ b/src/backend/kms/surface/timings.rs
@@ -143,7 +143,6 @@ impl Timings {
                 Time::elapsed(&frame.render_start, clock.now())
                     - frame
                         .render_duration_elements
-                        .clone()
                         .unwrap_or(Duration::ZERO),
             );
         }
@@ -271,7 +270,7 @@ impl Timings {
         }
         let secs = match (self.previous_frames.front(), self.previous_frames.back()) {
             (Some(Frame { render_start, .. }), Some(end_frame)) => {
-                Time::elapsed(render_start, end_frame.render_start.clone()) + end_frame.frame_time()
+                Time::elapsed(render_start, end_frame.render_start) + end_frame.frame_time()
             }
             _ => {
                 return 0.0;
diff --git a/src/backend/mod.rs b/src/backend/mod.rs
index a1fe8fcf0..14ad9e527 100644
--- a/src/backend/mod.rs
+++ b/src/backend/mod.rs
@@ -155,7 +155,7 @@ pub fn init_backend_auto(
                     .startup_done
                     .store(true, std::sync::atomic::Ordering::SeqCst);
                 for output in state.common.shell.read().outputs() {
-                    state.backend.schedule_render(&output);
+                    state.backend.schedule_render(output);
                 }
             }
         }
diff --git a/src/backend/render/cursor.rs b/src/backend/render/cursor.rs
index 4d183823b..b80fe1772 100644
--- a/src/backend/render/cursor.rs
+++ b/src/backend/render/cursor.rs
@@ -134,7 +134,7 @@ where
     R::TextureId: Clone + 'static,
 {
     let scale = scale.into();
-    let h = with_states(&surface, |states| {
+    let h = with_states(surface, |states| {
         states
             .data_map
             .get::<Mutex<CursorImageAttributes>>()
@@ -169,7 +169,7 @@ where
     R: Renderer + ImportAll,
     R::TextureId: Clone + 'static,
 {
-    if get_role(&surface) != Some("dnd_icon") {
+    if get_role(surface) != Some("dnd_icon") {
         warn!(
             ?surface,
             "Trying to display as a dnd icon a surface that does not have the DndIcon role."
@@ -320,7 +320,7 @@ where
                 MemoryRenderBufferRenderElement::from_buffer(
                     renderer,
                     location.to_physical(scale),
-                    &pointer_image,
+                    pointer_image,
                     None,
                     None,
                     None,
diff --git a/src/backend/render/element.rs b/src/backend/render/element.rs
index 767e223a3..ac4d0b64d 100644
--- a/src/backend/render/element.rs
+++ b/src/backend/render/element.rs
@@ -348,7 +348,7 @@ impl AsGlowRenderer for GlowRenderer {
     }
 }
 
-impl<'a> AsGlowRenderer for GlMultiRenderer<'a> {
+impl AsGlowRenderer for GlMultiRenderer<'_> {
     fn glow_renderer(&self) -> &GlowRenderer {
         self.as_ref()
     }
@@ -403,7 +403,7 @@ impl Element for DamageElement {
         scale: Scale<f64>,
         _commit: Option<CommitCounter>,
     ) -> DamageSet<i32, Physical> {
-        DamageSet::from_slice(&[Rectangle::from_size(self.geometry(scale).size).into()])
+        DamageSet::from_slice(&[Rectangle::from_size(self.geometry(scale).size)])
     }
 }
 
diff --git a/src/backend/render/mod.rs b/src/backend/render/mod.rs
index 02b011b2b..e11fc8327 100644
--- a/src/backend/render/mod.rs
+++ b/src/backend/render/mod.rs
@@ -93,7 +93,7 @@ pub enum RendererRef<'a> {
     GlMulti(GlMultiRenderer<'a>),
 }
 
-impl<'a> AsRef<GlowRenderer> for RendererRef<'a> {
+impl AsRef<GlowRenderer> for RendererRef<'_> {
     fn as_ref(&self) -> &GlowRenderer {
         match self {
             Self::Glow(renderer) => renderer,
@@ -102,7 +102,7 @@ impl<'a> AsRef<GlowRenderer> for RendererRef<'a> {
     }
 }
 
-impl<'a> AsMut<GlowRenderer> for RendererRef<'a> {
+impl AsMut<GlowRenderer> for RendererRef<'_> {
     fn as_mut(&mut self) -> &mut GlowRenderer {
         match self {
             Self::Glow(renderer) => renderer,
@@ -442,8 +442,8 @@ where
     let (focal_point, zoom_scale) = zoom_state
         .map(|state| {
             (
-                state.animating_focal_point(Some(&output)).to_local(&output),
-                state.animating_level(&output),
+                state.animating_focal_point(Some(output)).to_local(output),
+                state.animating_level(output),
             )
         })
         .unwrap_or_else(|| ((0., 0.).into(), 1.));
@@ -460,7 +460,7 @@ where
             elements.extend(
                 cursor::draw_cursor(
                     renderer,
-                    &seat,
+                    seat,
                     location,
                     scale.into(),
                     zoom_scale,
@@ -486,7 +486,7 @@ where
         }
 
         if !exclude_dnd_icon {
-            if let Some(dnd_icon) = get_dnd_icon(&seat) {
+            if let Some(dnd_icon) = get_dnd_icon(seat) {
                 elements.extend(
                     cursor::draw_dnd_icon(
                         renderer,
@@ -620,7 +620,7 @@ where
         return Ok(debug_elements);
     };
 
-    let (previous_idx, idx) = shell_guard.workspaces.active_num(&output);
+    let (previous_idx, idx) = shell_guard.workspaces.active_num(output);
     let previous_workspace = previous_workspace
         .zip(previous_idx)
         .map(|((w, start), idx)| (w.handle, idx, start));
@@ -694,7 +694,7 @@ where
     elements.extend(cursor_elements(
         renderer,
         seats.iter(),
-        zoom_level.clone(),
+        zoom_level,
         &theme,
         now,
         output,
@@ -752,8 +752,8 @@ where
     let (focal_point, zoom_scale) = zoom_level
         .map(|state| {
             (
-                state.animating_focal_point(Some(&output)).to_local(&output),
-                state.animating_level(&output),
+                state.animating_focal_point(Some(output)).to_local(output),
+                state.animating_level(output),
             )
         })
         .unwrap_or_else(|| ((0., 0.).into(), 1.));
@@ -761,7 +761,7 @@ where
     let crop_to_output = |element: WorkspaceRenderElement<R>| {
         CropRenderElement::from_element(
             RescaleRenderElement::from_element(
-                element.into(),
+                element,
                 focal_point
                     .as_logical()
                     .to_physical(output.current_scale().fractional_scale())
@@ -774,7 +774,7 @@ where
     };
 
     render_input_order::<()>(
-        &*shell,
+        &shell,
         output,
         previous,
         current,
@@ -817,7 +817,7 @@ where
                     elements.extend(
                         render_elements_from_surface_tree::<_, WorkspaceRenderElement<_>>(
                             renderer,
-                            &layer.wl_surface(),
+                            layer.wl_surface(),
                             location
                                 .to_local(output)
                                 .as_logical()
@@ -917,7 +917,7 @@ where
                                 resize_indicator.clone(),
                                 active_hint,
                                 alpha,
-                                &theme.cosmic(),
+                                theme.cosmic(),
                             )
                             .into_iter()
                             .map(Into::into)
@@ -932,7 +932,7 @@ where
                             last_active_seat,
                             !move_active && is_active_space,
                             overview.clone(),
-                            &theme.cosmic(),
+                            theme.cosmic(),
                         ) {
                             Ok(elements) => {
                                 elements
@@ -963,7 +963,7 @@ where
                             overview.clone(),
                             resize_indicator.clone(),
                             active_hint,
-                            &theme.cosmic(),
+                            theme.cosmic(),
                         ) {
                             Ok(elements) => {
                                 elements
@@ -1344,7 +1344,7 @@ where
             for (session, frame) in output.take_pending_frames() {
                 if let Some(pending_image_copy_data) = render_session::<_, _, GlesTexture>(
                     renderer,
-                    &session.user_data().get::<SessionData>().unwrap(),
+                    session.user_data().get::<SessionData>().unwrap(),
                     frame,
                     output.current_transform(),
                     |buffer, renderer, offscreen, dt, age, additional_damage| {
@@ -1496,7 +1496,7 @@ where
     )?;
 
     if let Some(additional_damage) = additional_damage {
-        let output_geo = output.geometry().to_local(&output).as_logical();
+        let output_geo = output.geometry().to_local(output).as_logical();
         elements.extend(
             additional_damage
                 .into_iter()
diff --git a/src/backend/winit.rs b/src/backend/winit.rs
index 0bee8fad5..1e79c42bb 100644
--- a/src/backend/winit.rs
+++ b/src/backend/winit.rs
@@ -143,7 +143,7 @@ pub fn init_backend(
 
     init_egl_client_side(dh, state, &mut backend)?;
 
-    let name = format!("WINIT-0");
+    let name = "WINIT-0".to_string();
     let size = backend.window_size();
     let props = PhysicalProperties {
         size: (0, 0).into(),
diff --git a/src/backend/x11.rs b/src/backend/x11.rs
index c1d098d33..d07b9c142 100644
--- a/src/backend/x11.rs
+++ b/src/backend/x11.rs
@@ -512,29 +512,26 @@ where
 impl State {
     pub fn process_x11_event(&mut self, event: InputEvent<X11Input>) {
         // here we can handle special cases for x11 inputs, like mapping them to windows
-        match &event {
-            InputEvent::PointerMotionAbsolute { event } => {
-                if let Some(window) = event.window() {
-                    let output = self
-                        .backend
-                        .x11()
-                        .surfaces
-                        .iter()
-                        .find(|surface| &surface.window == window.as_ref())
-                        .map(|surface| surface.output.clone())
-                        .unwrap();
-
-                    let device = event.device();
-                    for seat in self.common.shell.read().seats.iter() {
-                        let devices = seat.user_data().get::<Devices>().unwrap();
-                        if devices.has_device(&device) {
-                            seat.set_active_output(&output);
-                            break;
-                        }
+        if let InputEvent::PointerMotionAbsolute { event } = &event {
+            if let Some(window) = event.window() {
+                let output = self
+                    .backend
+                    .x11()
+                    .surfaces
+                    .iter()
+                    .find(|surface| &surface.window == window.as_ref())
+                    .map(|surface| surface.output.clone())
+                    .unwrap();
+
+                let device = event.device();
+                for seat in self.common.shell.read().seats.iter() {
+                    let devices = seat.user_data().get::<Devices>().unwrap();
+                    if devices.has_device(&device) {
+                        seat.set_active_output(&output);
+                        break;
                     }
                 }
             }
-            _ => {}
         };
 
         self.process_input_event(event);
diff --git a/src/config/input_config.rs b/src/config/input_config.rs
index 6371a23b4..e6cbb4884 100644
--- a/src/config/input_config.rs
+++ b/src/config/input_config.rs
@@ -92,11 +92,7 @@ pub fn get_config<'a, T: 'a, F: Fn(&'a InputConfig) -> Option<T>>(
 ) -> Option<(T, bool)> {
     if let Some(setting) = device_config.and_then(&f) {
         Some((setting, false))
-    } else if let Some(setting) = f(default_config) {
-        Some((setting, true))
-    } else {
-        None
-    }
+    } else { f(default_config).map(|setting| (setting, true)) }
 }
 
 fn config_set_error<T: std::fmt::Debug>(
diff --git a/src/config/mod.rs b/src/config/mod.rs
index c14a29f38..2febc075c 100644
--- a/src/config/mod.rs
+++ b/src/config/mod.rs
@@ -86,7 +86,7 @@ pub struct NumlockStateConfig {
 
 pub struct CompOutputConfig<'a>(pub Ref<'a, OutputConfig>);
 
-impl<'a> CompOutputConfig<'a> {
+impl CompOutputConfig<'_> {
     pub fn mode_size(&self) -> Size<i32, Physical> {
         self.0.mode.0.into()
     }
@@ -153,7 +153,7 @@ pub struct ScreenFilter {
 
 impl ScreenFilter {
     pub fn is_noop(&self) -> bool {
-        self.inverted == false && self.color_filter.is_none()
+        !self.inverted && self.color_filter.is_none()
     }
 }
 
@@ -582,7 +582,7 @@ impl Config {
                 )
             })
             .collect::<Vec<(OutputInfo, OutputConfig)>>();
-        infos.sort_by(|&(ref a, _), &(ref b, _)| a.cmp(b));
+        infos.sort_by(|(a, _), (b, _)| a.cmp(b));
         let (infos, configs) = infos.into_iter().unzip();
         self.dynamic_conf
             .outputs_mut()
@@ -642,20 +642,20 @@ impl Config {
 
 pub struct PersistenceGuard<'a, T: Serialize>(Option<PathBuf>, &'a mut T);
 
-impl<'a, T: Serialize> std::ops::Deref for PersistenceGuard<'a, T> {
+impl<T: Serialize> std::ops::Deref for PersistenceGuard<'_, T> {
     type Target = T;
     fn deref(&self) -> &T {
-        &self.1
+        self.1
     }
 }
 
-impl<'a, T: Serialize> std::ops::DerefMut for PersistenceGuard<'a, T> {
+impl<T: Serialize> std::ops::DerefMut for PersistenceGuard<'_, T> {
     fn deref_mut(&mut self) -> &mut T {
-        &mut self.1
+        self.1
     }
 }
 
-impl<'a, T: Serialize> Drop for PersistenceGuard<'a, T> {
+impl<T: Serialize> Drop for PersistenceGuard<'_, T> {
     fn drop(&mut self) {
         if let Some(path) = self.0.as_ref() {
             let content = match ron::ser::to_string_pretty(&self.1, Default::default()) {
diff --git a/src/dbus/mod.rs b/src/dbus/mod.rs
index e587e89b6..04c3f3601 100644
--- a/src/dbus/mod.rs
+++ b/src/dbus/mod.rs
@@ -50,7 +50,7 @@ pub fn init(evlh: &LoopHandle<'static, State>) -> Result<Vec<RegistrationToken>>
                             }
                         }
 
-                        ()
+                        
                     }
                     calloop::channel::Event::Closed => (),
                 })
@@ -61,8 +61,8 @@ pub fn init(evlh: &LoopHandle<'static, State>) -> Result<Vec<RegistrationToken>>
             let result = std::thread::Builder::new()
                 .name("system76-power-hotplug".to_string())
                 .spawn(move || {
-                    if let Ok(mut msg_iter) = power_daemon.receive_hot_plug_detect() {
-                        while let Some(msg) = msg_iter.next() {
+                    if let Ok(msg_iter) = power_daemon.receive_hot_plug_detect() {
+                        for msg in msg_iter {
                             if tx.send(msg).is_err() {
                                 break;
                             }
@@ -104,7 +104,7 @@ pub fn ready(common: &Common) -> Result<()> {
                 .xwayland_state
                 .as_ref()
                 .map(|s| format!(":{}", s.display))
-                .unwrap_or(String::new()),
+                .unwrap_or_default(),
         ),
     ]))?;
 
diff --git a/src/input/actions.rs b/src/input/actions.rs
index 90b99653c..9f74bf976 100644
--- a/src/input/actions.rs
+++ b/src/input/actions.rs
@@ -106,16 +106,16 @@ impl State {
         match action {
             SwipeAction::NextWorkspace => {
                 let _ = to_next_workspace(
-                    &mut *self.common.shell.write(),
-                    &seat,
+                    &mut self.common.shell.write(),
+                    seat,
                     true,
                     &mut self.common.workspace_state.update(),
                 );
             }
             SwipeAction::PrevWorkspace => {
                 let _ = to_previous_workspace(
-                    &mut *self.common.shell.write(),
-                    &seat,
+                    &mut self.common.shell.write(),
+                    seat,
                     true,
                     &mut self.common.workspace_state.update(),
                 );
@@ -201,7 +201,7 @@ impl State {
                 }
 
                 let next = to_next_workspace(
-                    &mut *self.common.shell.write(),
+                    &mut self.common.shell.write(),
                     seat,
                     false,
                     &mut self.common.workspace_state.update(),
@@ -247,7 +247,7 @@ impl State {
                 }
 
                 let previous = to_previous_workspace(
-                    &mut *self.common.shell.write(),
+                    &mut self.common.shell.write(),
                     seat,
                     false,
                     &mut self.common.workspace_state.update(),
@@ -543,7 +543,7 @@ impl State {
                         let workspace = shell.workspaces.active(&next_output).unwrap().1;
                         let new_target = workspace
                             .focus_stack
-                            .get(&seat)
+                            .get(seat)
                             .last()
                             .cloned()
                             .map(Into::<KeyboardFocusTarget>::into);
@@ -940,7 +940,7 @@ impl State {
                 let output = seat.active_output();
                 let mut shell = self.common.shell.write();
                 let workspace = shell.active_space_mut(&output).unwrap();
-                workspace.tiling_layer.update_orientation(None, &seat);
+                workspace.tiling_layer.update_orientation(None, seat);
             }
 
             Action::Orientation(orientation) => {
@@ -949,7 +949,7 @@ impl State {
                 let workspace = shell.active_space_mut(&output).unwrap();
                 workspace
                     .tiling_layer
-                    .update_orientation(Some(orientation), &seat);
+                    .update_orientation(Some(orientation), seat);
             }
 
             Action::ToggleStacking => {
@@ -1066,7 +1066,10 @@ impl State {
             .env("XDG_ACTIVATION_TOKEN", &*token)
             .env("DESKTOP_STARTUP_ID", &*token)
             .env_remove("COSMIC_SESSION_SOCK");
-        unsafe { cmd.pre_exec(|| Ok(crate::utils::rlimit::restore_nofile_limit())) };
+        unsafe { cmd.pre_exec(|| {
+            crate::utils::rlimit::restore_nofile_limit();
+            Ok(())
+        }) };
 
         std::thread::spawn(move || match cmd.spawn() {
             Ok(mut child) => {
@@ -1093,7 +1096,7 @@ impl State {
         if zoom_seat == *seat {
             let new_level = (current_level + change).max(1.0);
             shell.trigger_zoom(
-                &seat,
+                seat,
                 Some(&output),
                 new_level,
                 &self.common.config.cosmic_conf.accessibility_zoom,
diff --git a/src/input/gestures/mod.rs b/src/input/gestures/mod.rs
index 996d19cf1..c0aee70fd 100644
--- a/src/input/gestures/mod.rs
+++ b/src/input/gestures/mod.rs
@@ -50,12 +50,10 @@ impl GestureState {
                 } else {
                     Some(Direction::Left)
                 }
+            } else if movement.y > 0.0 {
+                Some(Direction::Down)
             } else {
-                if movement.y > 0.0 {
-                    Some(Direction::Down)
-                } else {
-                    Some(Direction::Up)
-                }
+                Some(Direction::Up)
             }
         }
 
diff --git a/src/input/mod.rs b/src/input/mod.rs
index 9c1f9c2d9..9047606f0 100644
--- a/src/input/mod.rs
+++ b/src/input/mod.rs
@@ -121,8 +121,7 @@ impl SupressedKeys {
         Some(
             removed
                 .into_iter()
-                .map(|(_, token)| token)
-                .flatten()
+                .filter_map(|(_, token)| token)
                 .collect::<Vec<_>>(),
         )
     }
@@ -314,7 +313,7 @@ impl State {
 
                     let mut position = seat.get_pointer().unwrap().current_location().as_global();
 
-                    let under = State::surface_under(position, &current_output, &mut *shell)
+                    let under = State::surface_under(position, &current_output, &mut shell)
                         .map(|(target, pos)| (target, pos.as_logical()));
 
                     let ptr = seat.get_pointer().unwrap();
@@ -329,7 +328,7 @@ impl State {
                         with_pointer_constraint(&surface, &ptr, |constraint| match constraint {
                             Some(constraint) if constraint.is_active() => {
                                 // Constraint does not apply if not within region
-                                if !constraint.region().map_or(true, |x| {
+                                if !constraint.region().is_none_or(|x| {
                                     x.contains(
                                         (ptr.current_location() - *surface_loc).to_i32_round(),
                                     )
@@ -358,7 +357,7 @@ impl State {
                         .cloned()
                         .unwrap_or(current_output.clone());
 
-                    let new_under = State::surface_under(position, &output, &mut *shell)
+                    let new_under = State::surface_under(position, &output, &mut shell)
                         .map(|(target, pos)| (target, pos.as_logical()));
 
                     std::mem::drop(shell);
@@ -382,12 +381,9 @@ impl State {
                             .user_data()
                             .get::<ResizeGrabMarker>()
                             .map(|marker| marker.get())
-                            .unwrap_or(false)
-                        {
-                            if output != current_output {
-                                ptr.frame(self);
-                                return;
-                            }
+                            .unwrap_or(false) && output != current_output {
+                            ptr.frame(self);
+                            return;
                         }
                         //If the pointer isn't grabbed, we should check if the focused element should be updated
                     } else if self.common.config.cosmic_conf.focus_follows_cursor {
@@ -395,11 +391,11 @@ impl State {
                         let old_keyboard_target = State::element_under(
                             original_position,
                             &current_output,
-                            &*shell,
+                            &shell,
                             &seat,
                         );
                         let new_keyboard_target =
-                            State::element_under(position, &output, &*shell, &seat);
+                            State::element_under(position, &output, &shell, &seat);
 
                         if old_keyboard_target != new_keyboard_target
                             && new_keyboard_target.is_some()
@@ -557,7 +553,7 @@ impl State {
                                 };
                                 let point =
                                     (ptr.current_location() - surface_location).to_i32_round();
-                                if region.map_or(true, |region| region.contains(point)) {
+                                if region.is_none_or(|region| region.contains(point)) {
                                     constraint.activate();
                                 }
                             }
@@ -574,7 +570,7 @@ impl State {
                     );
 
                     if output != current_output {
-                        for session in cursor_sessions_for_output(&*shell, &current_output) {
+                        for session in cursor_sessions_for_output(&shell, &current_output) {
                             session.set_cursor_pos(None);
                         }
                         seat.set_active_output(&output);
@@ -626,7 +622,7 @@ impl State {
                         .as_global();
                     let serial = SERIAL_COUNTER.next_serial();
                     let under =
-                        State::surface_under(position, &output, &mut *self.common.shell.write())
+                        State::surface_under(position, &output, &mut self.common.shell.write())
                             .map(|(target, pos)| (target, pos.as_logical()));
 
                     let ptr = seat.get_pointer().unwrap();
@@ -642,7 +638,7 @@ impl State {
                     ptr.frame(self);
 
                     let shell = self.common.shell.read();
-                    for session in cursor_sessions_for_output(&*shell, &output) {
+                    for session in cursor_sessions_for_output(&shell, &output) {
                         if let Some((geometry, offset)) = seat.cursor_geometry(
                             position.as_logical().to_buffer(
                                 output.current_scale().fractional_scale(),
@@ -922,7 +918,7 @@ impl State {
                                 percentage *= 5.;
                             }
 
-                            let change = -(percentage as f64 / 100.);
+                            let change = -(percentage / 100.);
                             self.update_zoom(&seat, change, event.source() == AxisSource::Wheel);
                         }
                     } else {
@@ -1249,7 +1245,7 @@ impl State {
                 if let Some(seat) = shell.seats.for_device(&event.device()).cloned() {
                     self.common.idle_notifier_state.notify_activity(&seat);
                     let Some(output) =
-                        mapped_output_for_device(&self.common.config, &*shell, &event.device())
+                        mapped_output_for_device(&self.common.config, &shell, &event.device())
                             .cloned()
                     else {
                         return;
@@ -1257,7 +1253,7 @@ impl State {
 
                     let position =
                         transform_output_mapped_position(&output, &event, shell.zoom_state());
-                    let under = State::surface_under(position, &output, &mut *shell)
+                    let under = State::surface_under(position, &output, &mut shell)
                         .map(|(target, pos)| (target, pos.as_logical()));
 
                     std::mem::drop(shell);
@@ -1281,7 +1277,7 @@ impl State {
                 if let Some(seat) = shell.seats.for_device(&event.device()).cloned() {
                     self.common.idle_notifier_state.notify_activity(&seat);
                     let Some(output) =
-                        mapped_output_for_device(&self.common.config, &*shell, &event.device())
+                        mapped_output_for_device(&self.common.config, &shell, &event.device())
                             .cloned()
                     else {
                         return;
@@ -1289,7 +1285,7 @@ impl State {
 
                     let position =
                         transform_output_mapped_position(&output, &event, shell.zoom_state());
-                    let under = State::surface_under(position, &output, &mut *shell)
+                    let under = State::surface_under(position, &output, &mut shell)
                         .map(|(target, pos)| (target, pos.as_logical()));
 
                     std::mem::drop(shell);
@@ -1372,7 +1368,7 @@ impl State {
 
                     let position =
                         transform_output_mapped_position(&output, &event, shell.zoom_state());
-                    let under = State::surface_under(position, &output, &mut *shell)
+                    let under = State::surface_under(position, &output, &mut shell)
                         .map(|(target, pos)| (target, pos.as_logical()));
 
                     std::mem::drop(shell);
@@ -1437,7 +1433,7 @@ impl State {
 
                     let position =
                         transform_output_mapped_position(&output, &event, shell.zoom_state());
-                    let under = State::surface_under(position, &output, &mut *shell)
+                    let under = State::surface_under(position, &output, &mut shell)
                         .map(|(target, pos)| (target, pos.as_logical()));
 
                     std::mem::drop(shell);
@@ -1602,7 +1598,7 @@ impl State {
             modifiers,
             &handle,
             event.state(),
-            event.time() as u64 * 1000,
+            event.time() * 1000,
         );
 
         // Leave move overview mode, if any modifier was released
@@ -1654,7 +1650,7 @@ impl State {
                 );
             } else if !cosmic_modifiers_eq_smithay(&action_pattern.modifiers, modifiers) {
                 let mut new_pattern = action_pattern.clone();
-                new_pattern.modifiers = cosmic_modifiers_from_smithay(modifiers.clone());
+                new_pattern.modifiers = cosmic_modifiers_from_smithay(*modifiers);
                 let enabled =
                     self.common
                         .config
@@ -1700,7 +1696,7 @@ impl State {
                     cosmic_keystate_from_smithay(event.state()),
                 ));
                 let key_pattern = shortcuts::Binding {
-                    modifiers: cosmic_modifiers_from_smithay(modifiers.clone()),
+                    modifiers: cosmic_modifiers_from_smithay(*modifiers),
                     keycode: None,
                     key: Some(handle.modified_sym()),
                     description: None,
@@ -1774,28 +1770,26 @@ impl State {
                 .active_virtual_mods
                 .remove(&event.key_code());
             // If `Caps_Lock` is a virtual modifier, and is in locked state, clear it
-            if removed && handle.modified_sym() == Keysym::Caps_Lock {
-                if (modifiers.serialized.locked & 2) != 0 {
-                    let serial = SERIAL_COUNTER.next_serial();
-                    let time = self.common.clock.now().as_millis();
-                    keyboard.input(
-                        self,
-                        event.key_code(),
-                        KeyState::Pressed,
-                        serial,
-                        time,
-                        |_, _, _| FilterResult::<()>::Forward,
-                    );
-                    let serial = SERIAL_COUNTER.next_serial();
-                    keyboard.input(
-                        self,
-                        event.key_code(),
-                        KeyState::Released,
-                        serial,
-                        time,
-                        |_, _, _| FilterResult::<()>::Forward,
-                    );
-                }
+            if removed && handle.modified_sym() == Keysym::Caps_Lock && (modifiers.serialized.locked & 2) != 0 {
+                let serial = SERIAL_COUNTER.next_serial();
+                let time = self.common.clock.now().as_millis();
+                keyboard.input(
+                    self,
+                    event.key_code(),
+                    KeyState::Pressed,
+                    serial,
+                    time,
+                    |_, _, _| FilterResult::<()>::Forward,
+                );
+                let serial = SERIAL_COUNTER.next_serial();
+                keyboard.input(
+                    self,
+                    event.key_code(),
+                    KeyState::Released,
+                    serial,
+                    time,
+                    |_, _, _| FilterResult::<()>::Forward,
+                );
             }
         } else if event.state() == KeyState::Pressed
             && self
@@ -1918,7 +1912,7 @@ impl State {
         if let Some(focus) = current_focus {
             if let Some(new_descriptor) = shell
                 .workspaces
-                .active(&focused_output)
+                .active(focused_output)
                 .unwrap()
                 .1
                 .node_desc(focus)
@@ -1933,7 +1927,7 @@ impl State {
                             .find(|w| w.handle == new_descriptor.handle)
                         {
                             {
-                                let mut stack = new_workspace.focus_stack.get_mut(&seat);
+                                let mut stack = new_workspace.focus_stack.get_mut(seat);
                                 for elem in old_descriptor.focus_stack.iter().flat_map(|node_id| {
                                     old_workspace.tiling_layer.element_for_node(node_id)
                                 }) {
@@ -1941,7 +1935,7 @@ impl State {
                                 }
                             }
                             {
-                                let mut stack = old_workspace.focus_stack.get_mut(&seat);
+                                let mut stack = old_workspace.focus_stack.get_mut(seat);
                                 for elem in new_descriptor.focus_stack.iter().flat_map(|node_id| {
                                     new_workspace.tiling_layer.element_for_node(node_id)
                                 }) {
@@ -1951,7 +1945,7 @@ impl State {
                             if let Some(focus) = TilingLayout::swap_trees(
                                 &mut old_workspace.tiling_layer,
                                 Some(&mut new_workspace.tiling_layer),
-                                &old_descriptor,
+                                old_descriptor,
                                 &new_descriptor,
                             ) {
                                 let seat = seat.clone();
@@ -1963,26 +1957,24 @@ impl State {
                             new_workspace.refresh_focus_stack();
                         }
                     }
-                } else {
-                    if let Some(workspace) = spaces.find(|w| w.handle == new_descriptor.handle) {
-                        if let Some(focus) = TilingLayout::swap_trees(
-                            &mut workspace.tiling_layer,
-                            None,
-                            &old_descriptor,
-                            &new_descriptor,
-                        ) {
-                            std::mem::drop(spaces);
-                            let seat = seat.clone();
-                            self.common.event_loop_handle.insert_idle(move |state| {
-                                Shell::set_focus(state, Some(&focus), &seat, None, true);
-                            });
-                        }
-                        workspace.refresh_focus_stack();
+                } else if let Some(workspace) = spaces.find(|w| w.handle == new_descriptor.handle) {
+                    if let Some(focus) = TilingLayout::swap_trees(
+                        &mut workspace.tiling_layer,
+                        None,
+                        old_descriptor,
+                        &new_descriptor,
+                    ) {
+                        std::mem::drop(spaces);
+                        let seat = seat.clone();
+                        self.common.event_loop_handle.insert_idle(move |state| {
+                            Shell::set_focus(state, Some(&focus), &seat, None, true);
+                        });
                     }
+                    workspace.refresh_focus_stack();
                 }
             }
         } else {
-            let new_workspace = shell.workspaces.active(&focused_output).unwrap().1.handle;
+            let new_workspace = shell.workspaces.active(focused_output).unwrap().1.handle;
             if new_workspace != old_descriptor.handle {
                 let spaces = shell.workspaces.spaces_mut();
                 let (mut old_w, mut other_w) =
@@ -1993,7 +1985,7 @@ impl State {
                     {
                         if new_workspace.tiling_layer.windows().next().is_none() {
                             {
-                                let mut stack = new_workspace.focus_stack.get_mut(&seat);
+                                let mut stack = new_workspace.focus_stack.get_mut(seat);
                                 for elem in old_descriptor.focus_stack.iter().flat_map(|node_id| {
                                     old_workspace.tiling_layer.element_for_node(node_id)
                                 }) {
@@ -2004,8 +1996,8 @@ impl State {
                                 &mut old_workspace.tiling_layer,
                                 &mut new_workspace.tiling_layer,
                                 &new_workspace.handle,
-                                &seat,
-                                new_workspace.focus_stack.get(&seat).iter(),
+                                seat,
+                                new_workspace.focus_stack.get(seat).iter(),
                                 old_descriptor.clone(),
                                 None,
                             ) {
@@ -2314,7 +2306,7 @@ fn cursor_sessions_for_output<'a>(
     output: &'a Output,
 ) -> impl Iterator<Item = CursorSessionRef> + 'a {
     shell
-        .active_space(&output)
+        .active_space(output)
         .into_iter()
         .flat_map(|workspace| {
             let maybe_fullscreen = workspace.get_fullscreen();
@@ -2327,7 +2319,7 @@ fn cursor_sessions_for_output<'a>(
                         .into_iter()
                         .flatten(),
                 )
-                .chain(output.cursor_sessions().into_iter())
+                .chain(output.cursor_sessions())
         })
 }
 
diff --git a/src/main.rs b/src/main.rs
index 999f621f8..27222d639 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -80,7 +80,10 @@ impl State {
                 command.envs(
                     session::get_env(&self.common).expect("WAYLAND_DISPLAY should be valid UTF-8"),
                 );
-                unsafe { command.pre_exec(|| Ok(utils::rlimit::restore_nofile_limit())) };
+                unsafe { command.pre_exec(|| {
+                    utils::rlimit::restore_nofile_limit();
+                    Ok(())
+                }) };
 
                 info!("Running {:?}", exec);
                 command
@@ -172,7 +175,7 @@ fn main_inner() -> Result<(), Box<dyn Error>> {
         {
             let dh = state.common.display_handle.clone();
             for client in clients.values() {
-                client_compositor_state(&client).blocker_cleared(state, &dh);
+                client_compositor_state(client).blocker_cleared(state, &dh);
             }
         }
 
diff --git a/src/session.rs b/src/session.rs
index 755fbd3e2..6c61fb6da 100644
--- a/src/session.rs
+++ b/src/session.rs
@@ -133,11 +133,11 @@ pub fn setup_socket(handle: LoopHandle<State>, common: &Common) -> Result<()> {
                         stream.read_bytes = 0;
                         match std::str::from_utf8(&stream.buffer) {
                             Ok(message) => {
-                                match serde_json::from_str::<'_, Message>(&message) {
+                                match serde_json::from_str::<'_, Message>(message) {
                                     Ok(Message::NewPrivilegedClient { count }) => {
                                         let mut buffer = [0; 1];
                                         let mut fds = vec![0; count];
-                                        match stream.stream.recv_with_fd(&mut buffer, &mut *fds) {
+                                        match stream.stream.recv_with_fd(&mut buffer, &mut fds) {
                                             Ok((_, received_count)) => {
                                                 assert_eq!(received_count, count);
                                                 for fd in fds.into_iter().take(received_count) {
diff --git a/src/shell/element/mod.rs b/src/shell/element/mod.rs
index 06b2a07d9..c33a0bd9d 100644
--- a/src/shell/element/mod.rs
+++ b/src/shell/element/mod.rs
@@ -241,10 +241,7 @@ impl CosmicMapped {
     }
 
     pub fn focus_window(&self, window: &CosmicSurface) {
-        match &self.element {
-            CosmicMappedInternal::Stack(stack) => stack.set_active(window),
-            _ => {}
-        }
+        if let CosmicMappedInternal::Stack(stack) = &self.element { stack.set_active(window) }
     }
 
     pub fn has_surface(&self, surface: &WlSurface, surface_type: WindowSurfaceType) -> bool {
@@ -446,7 +443,7 @@ impl CosmicMapped {
     pub fn set_bounds(&self, size: impl Into<Option<Size<i32, Logical>>>) {
         let size = size.into();
         for (surface, _) in self.windows() {
-            surface.set_bounds(size.clone())
+            surface.set_bounds(size)
         }
     }
 
@@ -508,24 +505,21 @@ impl CosmicMapped {
         (output, overlap): (&Output, Rectangle<i32, Logical>),
         theme: cosmic::Theme,
     ) {
-        match &self.element {
-            CosmicMappedInternal::Window(window) => {
-                let surface = window.surface();
-                let activated = surface.is_activated(true);
-                let handle = window.loop_handle();
-
-                let stack = CosmicStack::new(std::iter::once(surface), handle, theme);
-                if let Some(geo) = self.last_geometry.lock().unwrap().clone() {
-                    stack.set_geometry(geo.to_global(&output));
-                }
-                stack.output_enter(output, overlap);
-                stack.set_activate(activated);
-                stack.active().send_configure();
-                stack.refresh();
-
-                self.element = CosmicMappedInternal::Stack(stack);
+        if let CosmicMappedInternal::Window(window) = &self.element {
+            let surface = window.surface();
+            let activated = surface.is_activated(true);
+            let handle = window.loop_handle();
+
+            let stack = CosmicStack::new(std::iter::once(surface), handle, theme);
+            if let Some(geo) = *self.last_geometry.lock().unwrap() {
+                stack.set_geometry(geo.to_global(output));
             }
-            _ => {}
+            stack.output_enter(output, overlap);
+            stack.set_activate(activated);
+            stack.active().send_configure();
+            stack.refresh();
+
+            self.element = CosmicMappedInternal::Stack(stack);
         }
     }
 
@@ -540,8 +534,8 @@ impl CosmicMapped {
         surface.set_tiled(false);
         let window = CosmicWindow::new(surface, handle, theme);
 
-        if let Some(geo) = self.last_geometry.lock().unwrap().clone() {
-            window.set_geometry(geo.to_global(&output));
+        if let Some(geo) = *self.last_geometry.lock().unwrap() {
+            window.set_geometry(geo.to_global(output));
         }
         window.output_enter(output, overlap);
         window.set_activate(self.is_activated(true));
@@ -843,7 +837,7 @@ impl CosmicMapped {
     pub fn ssd_height(&self, pending: bool) -> Option<i32> {
         match &self.element {
             CosmicMappedInternal::Window(w) => (!w.surface().is_decorated(pending))
-                .then(|| crate::shell::element::window::SSD_HEIGHT),
+                .then_some(crate::shell::element::window::SSD_HEIGHT),
             CosmicMappedInternal::Stack(_) => Some(crate::shell::element::stack::TAB_HEIGHT),
             _ => unreachable!(),
         }
diff --git a/src/shell/element/stack.rs b/src/shell/element/stack.rs
index 2d5ee0a60..53ef1cbf0 100644
--- a/src/shell/element/stack.rs
+++ b/src/shell/element/stack.rs
@@ -180,7 +180,7 @@ impl CosmicStack {
                 *prev_idx = last_mod_serial.map(|s| (s, p.active.load(Ordering::SeqCst)));
             }
 
-            if let Some(mut geo) = p.geometry.lock().unwrap().clone() {
+            if let Some(mut geo) = *p.geometry.lock().unwrap() {
                 geo.loc.y += TAB_HEIGHT;
                 geo.size.h -= TAB_HEIGHT;
                 window.set_geometry(geo, TAB_HEIGHT as u32);
@@ -210,7 +210,7 @@ impl CosmicStack {
             let mut windows = p.windows.lock().unwrap();
             if windows.len() == 1 {
                 p.override_alive.store(false, Ordering::SeqCst);
-                let window = windows.get(0).unwrap();
+                let window = windows.first().unwrap();
                 window.try_force_undecorated(false);
                 window.set_tiled(false);
                 return;
@@ -238,7 +238,7 @@ impl CosmicStack {
             let mut windows = p.windows.lock().unwrap();
             if windows.len() == 1 {
                 p.override_alive.store(false, Ordering::SeqCst);
-                let window = windows.get(0).unwrap();
+                let window = windows.first().unwrap();
                 window.try_force_undecorated(false);
                 window.set_tiled(false);
                 return Some(window.clone());
@@ -545,10 +545,9 @@ impl CosmicStack {
 
     pub fn pending_size(&self) -> Option<Size<i32, Logical>> {
         self.0.with_program(|p| {
-            p.geometry
+            (*p.geometry
                 .lock()
-                .unwrap()
-                .clone()
+                .unwrap())
                 .map(|geo| geo.size.as_logical())
         })
     }
@@ -1466,17 +1465,11 @@ impl PointerTarget<State> for CosmicStack {
     }
 
     fn axis(&self, seat: &Seat<State>, data: &mut State, frame: AxisFrame) {
-        match self.0.with_program(|p| p.current_focus()) {
-            Some(Focus::Header) => PointerTarget::axis(&self.0, seat, data, frame),
-            _ => {}
-        }
+        if let Some(Focus::Header) = self.0.with_program(|p| p.current_focus()) { PointerTarget::axis(&self.0, seat, data, frame) }
     }
 
     fn frame(&self, seat: &Seat<State>, data: &mut State) {
-        match self.0.with_program(|p| p.current_focus()) {
-            Some(Focus::Header) => PointerTarget::frame(&self.0, seat, data),
-            _ => {}
-        }
+        if let Some(Focus::Header) = self.0.with_program(|p| p.current_focus()) { PointerTarget::frame(&self.0, seat, data) }
     }
 
     fn leave(&self, seat: &Seat<State>, data: &mut State, serial: Serial, time: u32) {
@@ -1607,7 +1600,7 @@ impl TouchTarget<State> for CosmicStack {
     }
 
     fn up(&self, seat: &Seat<State>, data: &mut State, event: &UpEvent, seq: Serial) {
-        TouchTarget::up(&self.0, seat, data, &event, seq)
+        TouchTarget::up(&self.0, seat, data, event, seq)
     }
 
     fn motion(&self, seat: &Seat<State>, data: &mut State, event: &TouchMotionEvent, seq: Serial) {
diff --git a/src/shell/element/stack/tab.rs b/src/shell/element/stack/tab.rs
index b2fcdba90..858bcfe86 100644
--- a/src/shell/element/stack/tab.rs
+++ b/src/shell/element/stack/tab.rs
@@ -239,7 +239,7 @@ pub(super) struct TabInternal<'a, Message: TabMessage> {
     right_click_message: Option<Message>,
 }
 
-impl<'a, Message> Widget<Message, cosmic::Theme, cosmic::Renderer> for TabInternal<'a, Message>
+impl<Message> Widget<Message, cosmic::Theme, cosmic::Renderer> for TabInternal<'_, Message>
 where
     Message: TabMessage,
 {
diff --git a/src/shell/element/stack/tabs.rs b/src/shell/element/stack/tabs.rs
index e44a39cbc..66e06db10 100644
--- a/src/shell/element/stack/tabs.rs
+++ b/src/shell/element/stack/tabs.rs
@@ -125,7 +125,7 @@ impl Offset {
 const SCROLL_ANIMATION_DURATION: Duration = Duration::from_millis(200);
 const TAB_ANIMATION_DURATION: Duration = Duration::from_millis(150);
 
-impl<'a, Message> Tabs<'a, Message>
+impl<Message> Tabs<'_, Message>
 where
     Message: TabMessage + 'static,
 {
@@ -308,7 +308,7 @@ impl State {
     }
 }
 
-impl<'a, Message> Widget<Message, cosmic::Theme, cosmic::Renderer> for Tabs<'a, Message>
+impl<Message> Widget<Message, cosmic::Theme, cosmic::Renderer> for Tabs<'_, Message>
 where
     Message: TabMessage,
 {
diff --git a/src/shell/element/surface.rs b/src/shell/element/surface.rs
index d8ce0e17b..9da424ffa 100644
--- a/src/shell/element/surface.rs
+++ b/src/shell/element/surface.rs
@@ -81,14 +81,13 @@ impl From<X11Surface> for CosmicSurface {
 
 impl PartialEq<WlSurface> for CosmicSurface {
     fn eq(&self, other: &WlSurface) -> bool {
-        self.wl_surface().map_or(false, |s| &*s == other)
+        self.wl_surface().is_some_and(|s| &*s == other)
     }
 }
 
 impl PartialEq<ToplevelSurface> for CosmicSurface {
     fn eq(&self, other: &ToplevelSurface) -> bool {
-        self.wl_surface()
-            .map_or(false, |s| &*s == other.wl_surface())
+        self.wl_surface().is_some_and(|s| &*s == other.wl_surface())
     }
 }
 
@@ -280,7 +279,7 @@ impl CosmicSurface {
             WindowSurface::Wayland(toplevel) => {
                 if enable {
                     let previous_decoration_state =
-                        toplevel.current_state().decoration_mode.clone();
+                        toplevel.current_state().decoration_mode;
                     if PreferredDecorationMode::is_unset(&self.0) {
                         PreferredDecorationMode::update(&self.0, previous_decoration_state);
                     }
@@ -639,10 +638,8 @@ impl CosmicSurface {
             return false;
         };
 
-        if surface_type.contains(WindowSurfaceType::TOPLEVEL) {
-            if *toplevel == *surface {
-                return true;
-            }
+        if surface_type.contains(WindowSurfaceType::TOPLEVEL) && *toplevel == *surface {
+            return true;
         }
 
         if surface_type.contains(WindowSurfaceType::SUBSURFACE) {
diff --git a/src/shell/element/window.rs b/src/shell/element/window.rs
index 3b5f557ab..465773596 100644
--- a/src/shell/element/window.rs
+++ b/src/shell/element/window.rs
@@ -252,7 +252,7 @@ impl CosmicWindow {
                 let geo = p.window.geometry();
 
                 let point_i32 = relative_pos.to_i32_round::<i32>();
-                let ssd_height = has_ssd.then_some(SSD_HEIGHT).unwrap_or(0);
+                let ssd_height = if has_ssd { SSD_HEIGHT } else { 0 };
 
                 if (point_i32.x - geo.loc.x >= -RESIZE_BORDER && point_i32.x - geo.loc.x < 0)
                     || (point_i32.y - geo.loc.y >= -RESIZE_BORDER && point_i32.y - geo.loc.y < 0)
@@ -708,7 +708,7 @@ impl PointerTarget<State> for CosmicWindow {
             if has_ssd || p.is_tiled(false) {
                 let Some(next) = Focus::under(
                     &p.window,
-                    has_ssd.then_some(SSD_HEIGHT).unwrap_or(0),
+                    if has_ssd { SSD_HEIGHT } else { 0 },
                     event.location,
                 ) else {
                     return;
@@ -734,7 +734,7 @@ impl PointerTarget<State> for CosmicWindow {
             if has_ssd || p.is_tiled(false) {
                 let Some(next) = Focus::under(
                     &p.window,
-                    has_ssd.then_some(SSD_HEIGHT).unwrap_or(0),
+                    if has_ssd { SSD_HEIGHT } else { 0 },
                     event.location,
                 ) else {
                     return;
@@ -804,17 +804,11 @@ impl PointerTarget<State> for CosmicWindow {
     }
 
     fn axis(&self, seat: &Seat<State>, data: &mut State, frame: AxisFrame) {
-        match self.0.with_program(|p| p.current_focus()) {
-            Some(Focus::Header) => PointerTarget::axis(&self.0, seat, data, frame),
-            _ => {}
-        }
+        if let Some(Focus::Header) = self.0.with_program(|p| p.current_focus()) { PointerTarget::axis(&self.0, seat, data, frame) }
     }
 
     fn frame(&self, seat: &Seat<State>, data: &mut State) {
-        match self.0.with_program(|p| p.current_focus()) {
-            Some(Focus::Header) => PointerTarget::frame(&self.0, seat, data),
-            _ => {}
-        }
+        if let Some(Focus::Header) = self.0.with_program(|p| p.current_focus()) { PointerTarget::frame(&self.0, seat, data) }
     }
 
     fn leave(&self, seat: &Seat<State>, data: &mut State, serial: Serial, time: u32) {
@@ -901,7 +895,7 @@ impl TouchTarget<State> for CosmicWindow {
     }
 
     fn up(&self, seat: &Seat<State>, data: &mut State, event: &UpEvent, seq: Serial) {
-        TouchTarget::up(&self.0, seat, data, &event, seq)
+        TouchTarget::up(&self.0, seat, data, event, seq)
     }
 
     fn motion(&self, seat: &Seat<State>, data: &mut State, event: &TouchMotionEvent, seq: Serial) {
diff --git a/src/shell/focus/mod.rs b/src/shell/focus/mod.rs
index 28719a606..e402f69e2 100644
--- a/src/shell/focus/mod.rs
+++ b/src/shell/focus/mod.rs
@@ -59,9 +59,9 @@ impl From<CosmicSurface> for FocusTarget {
     }
 }
 
-impl Into<KeyboardFocusTarget> for FocusTarget {
-    fn into(self) -> KeyboardFocusTarget {
-        match self {
+impl From<FocusTarget> for KeyboardFocusTarget {
+    fn from(val: FocusTarget) -> Self {
+        match val {
             FocusTarget::Window(mapped) => KeyboardFocusTarget::Element(mapped),
             FocusTarget::Fullscreen(surface) => KeyboardFocusTarget::Fullscreen(surface),
         }
@@ -94,7 +94,7 @@ impl FocusTarget {
 pub struct FocusStack<'a>(pub(super) Option<&'a IndexSet<FocusTarget>>);
 pub struct FocusStackMut<'a>(pub(super) &'a mut IndexSet<FocusTarget>);
 
-impl<'a> FocusStack<'a> {
+impl FocusStack<'_> {
     /// returns the last unminimized window in the focus stack that is still alive
     pub fn last(&self) -> Option<&FocusTarget> {
         self.0
@@ -109,7 +109,7 @@ impl<'a> FocusStack<'a> {
     }
 }
 
-impl<'a> FocusStackMut<'a> {
+impl FocusStackMut<'_> {
     pub fn append(&mut self, target: impl Into<FocusTarget>) {
         let target = target.into();
         self.0.retain(|w| w.alive());
@@ -232,7 +232,7 @@ impl Shell {
         let focused_windows = self
             .seats
             .iter()
-            .map(|seat| {
+            .filter_map(|seat| {
                 if matches!(
                     seat.get_keyboard().unwrap().current_focus(),
                     Some(KeyboardFocusTarget::Group(_)) | Some(KeyboardFocusTarget::LockSurface(_))
@@ -248,7 +248,6 @@ impl Shell {
                     FocusTarget::Fullscreen(_) => None,
                 })
             })
-            .flatten()
             .collect::<Vec<_>>();
 
         for output in self.outputs().cloned().collect::<Vec<_>>().into_iter() {
@@ -257,7 +256,7 @@ impl Shell {
                 raise_with_children(&mut set.sticky_layer, focused);
             }
             for window in set.sticky_layer.mapped() {
-                window.set_activated(focused_windows.contains(&window));
+                window.set_activated(focused_windows.contains(window));
                 window.configure();
             }
             for window in set
@@ -291,7 +290,7 @@ impl Shell {
                 raise_with_children(&mut workspace.floating_layer, focused);
             }
             for window in workspace.mapped() {
-                window.set_activated(focused_windows.contains(&window));
+                window.set_activated(focused_windows.contains(window));
                 window.configure();
             }
             for m in workspace.minimized_windows.iter() {
@@ -330,38 +329,36 @@ fn update_focus_state(
 ) {
     // update keyboard focus
     if let Some(keyboard) = seat.get_keyboard() {
-        if should_update_cursor && state.common.config.cosmic_conf.cursor_follows_focus {
-            if target.is_some() {
-                //need to borrow mutably for surface under
-                let shell = state.common.shell.read();
-                // get the top left corner of the target element
-                let geometry = shell.focused_geometry(target.unwrap());
-                if let Some(geometry) = geometry {
-                    // get the center of the target element
-                    let window_center = Point::from((geometry.size.w / 2, geometry.size.h / 2));
-                    let new_pos = (geometry.loc + window_center).to_f64();
-
-                    // create a pointer target from the target element
-                    let output = shell
-                        .outputs()
-                        .find(|output| output.geometry().to_f64().contains(new_pos))
-                        .cloned()
-                        .unwrap_or(seat.active_output());
-
-                    let focus = State::surface_under(new_pos, &output, &*shell)
-                        .map(|(focus, loc)| (focus, loc.as_logical()));
-                    //drop here to avoid multiple borrows
-                    mem::drop(shell);
-                    seat.get_pointer().unwrap().motion(
-                        state,
-                        focus,
-                        &MotionEvent {
-                            location: new_pos.as_logical(),
-                            serial: SERIAL_COUNTER.next_serial(),
-                            time: 0,
-                        },
-                    );
-                }
+        if should_update_cursor && state.common.config.cosmic_conf.cursor_follows_focus && target.is_some() {
+            //need to borrow mutably for surface under
+            let shell = state.common.shell.read();
+            // get the top left corner of the target element
+            let geometry = shell.focused_geometry(target.unwrap());
+            if let Some(geometry) = geometry {
+                // get the center of the target element
+                let window_center = Point::from((geometry.size.w / 2, geometry.size.h / 2));
+                let new_pos = (geometry.loc + window_center).to_f64();
+
+                // create a pointer target from the target element
+                let output = shell
+                    .outputs()
+                    .find(|output| output.geometry().to_f64().contains(new_pos))
+                    .cloned()
+                    .unwrap_or(seat.active_output());
+
+                let focus = State::surface_under(new_pos, &output, &shell)
+                    .map(|(focus, loc)| (focus, loc.as_logical()));
+                //drop here to avoid multiple borrows
+                mem::drop(shell);
+                seat.get_pointer().unwrap().motion(
+                    state,
+                    focus,
+                    &MotionEvent {
+                        location: new_pos.as_logical(),
+                        serial: SERIAL_COUNTER.next_serial(),
+                        time: 0,
+                    },
+                );
             }
         }
 
@@ -460,15 +457,15 @@ impl Common {
                 }
             }
 
-            update_pointer_focus(state, &seat);
+            update_pointer_focus(state, seat);
 
             let output = seat.focused_or_active_output();
             let mut shell = state.common.shell.write();
-            let last_known_focus = ActiveFocus::get(&seat);
+            let last_known_focus = ActiveFocus::get(seat);
 
             if let Some(target) = last_known_focus {
                 if target.alive() {
-                    if focus_target_is_valid(&mut *shell, &seat, &output, target) {
+                    if focus_target_is_valid(&mut shell, seat, &output, target) {
                         continue; // Focus is valid
                     } else {
                         trace!("Wrong Window, focus fixup");
@@ -504,7 +501,7 @@ impl Common {
                 }
             } else {
                 let workspace = shell.active_space(&output).unwrap();
-                let focus_stack = workspace.focus_stack.get(&seat);
+                let focus_stack = workspace.focus_stack.get(seat);
 
                 if focus_stack.last().is_none() {
                     continue; // Focus is valid
@@ -527,7 +524,7 @@ impl Common {
                 }
 
                 // update keyboard focus
-                let target = update_focus_target(&*shell, &seat, &output);
+                let target = update_focus_target(&shell, seat, &output);
                 std::mem::drop(shell);
                 //I can probably feature gate this condition
                 debug!("Restoring focus to {:?}", target.as_ref());
@@ -547,8 +544,8 @@ impl Common {
                     .as_ref()
                     .and_then(|t| t.wl_surface())
                     .and_then(|s| state.common.display_handle.get_client(s.id()).ok());
-                set_data_device_focus(&state.common.display_handle, &seat, client.clone());
-                set_primary_focus(&state.common.display_handle, &seat, client);
+                set_data_device_focus(&state.common.display_handle, seat, client.clone());
+                set_primary_focus(&state.common.display_handle, seat, client);
             }
         }
 
@@ -603,8 +600,8 @@ fn focus_target_is_valid(
                 .mapped()
                 .any(|m| m == &mapped);
 
-            let workspace = shell.active_space(&output).unwrap();
-            let focus_stack = workspace.focus_stack.get(&seat);
+            let workspace = shell.active_space(output).unwrap();
+            let focus_stack = workspace.focus_stack.get(seat);
             let is_in_focus_stack = focus_stack.last().map(|m| m == &mapped).unwrap_or(false);
             if is_sticky && !is_in_focus_stack {
                 shell.append_focus_stack(mapped, seat);
@@ -613,17 +610,17 @@ fn focus_target_is_valid(
             is_sticky || is_in_focus_stack
         }
         KeyboardFocusTarget::LayerSurface(layer) => {
-            layer_map_for_output(&output).layers().any(|l| l == &layer)
+            layer_map_for_output(output).layers().any(|l| l == &layer)
         }
         KeyboardFocusTarget::Group(WindowGroup { node, .. }) => shell
             .workspaces
-            .active(&output)
+            .active(output)
             .unwrap()
             .1
             .tiling_layer
             .has_node(&node),
         KeyboardFocusTarget::Fullscreen(window) => {
-            let workspace = shell.active_space(&output).unwrap();
+            let workspace = shell.active_space(output).unwrap();
             workspace.get_fullscreen().is_some_and(|w| w == &window)
         }
         KeyboardFocusTarget::Popup(_) => true,
@@ -654,15 +651,15 @@ fn update_focus_target(
             .map(KeyboardFocusTarget::from)
     } else {
         shell
-            .active_space(&output)
+            .active_space(output)
             .unwrap()
             .focus_stack
-            .get(&seat)
+            .get(seat)
             .last()
             .cloned()
             .map(Into::<KeyboardFocusTarget>::into)
             .or_else(|| {
-                let workspace = shell.active_space(&output).unwrap();
+                let workspace = shell.active_space(output).unwrap();
 
                 workspace
                     .mapped()
@@ -710,10 +707,8 @@ fn exclusive_layer_surface_layer(shell: &Shell) -> Option<Layer> {
     for output in shell.outputs() {
         for layer_surface in layer_map_for_output(output).layers() {
             let data = layer_surface.cached_state();
-            if data.keyboard_interactivity == KeyboardInteractivity::Exclusive {
-                if data.layer as u32 >= layer.unwrap_or(Layer::Top) as u32 {
-                    layer = Some(data.layer);
-                }
+            if data.keyboard_interactivity == KeyboardInteractivity::Exclusive && data.layer as u32 >= layer.unwrap_or(Layer::Top) as u32 {
+                layer = Some(data.layer);
             }
         }
     }
diff --git a/src/shell/focus/order.rs b/src/shell/focus/order.rs
index ce1a38cec..e9ca57096 100644
--- a/src/shell/focus/order.rs
+++ b/src/shell/focus/order.rs
@@ -125,13 +125,13 @@ fn render_input_order_internal<R: 'static>(
         .last()
         .zip(fullscreen)
         .is_some_and(|(target, fullscreen)| target == &fullscreen.surface);
-    let overview_is_open = workspace_overview_is_open(&output);
+    let overview_is_open = workspace_overview_is_open(output);
     let has_focused_fullscreen = if is_active_workspace {
         let current_focus = seat.get_keyboard().unwrap().current_focus();
         matches!(current_focus, Some(KeyboardFocusTarget::Fullscreen(_)))
             || (current_focus.is_none()
                 && focus_stack_is_valid_fullscreen
-                && !workspace_overview_is_open(&output))
+                && !workspace_overview_is_open(output))
     } else {
         focus_stack_is_valid_fullscreen && !overview_is_open
     };
@@ -141,7 +141,7 @@ fn render_input_order_internal<R: 'static>(
         Some((previous, previous_idx, start)) => {
             let layout = shell.workspaces.layout;
 
-            let Some(workspace) = shell.workspaces.space_for_handle(&previous) else {
+            let Some(workspace) = shell.workspaces.space_for_handle(previous) else {
                 return ControlFlow::Break(Err(OutputNoMode));
             };
             let has_fullscreen = workspace.fullscreen.is_some();
@@ -368,13 +368,13 @@ fn render_input_order_internal<R: 'static>(
     ControlFlow::Continue(())
 }
 
-fn layer_popups<'a>(
-    output: &'a Output,
+fn layer_popups(
+    output: &Output,
     layer: Layer,
     element_filter: ElementFilter,
-) -> impl Iterator<Item = (LayerSurface, PopupKind, Point<i32, Global>)> + 'a {
+) -> impl Iterator<Item = (LayerSurface, PopupKind, Point<i32, Global>)> + '_ {
     layer_surfaces(output, layer, element_filter).flat_map(move |(surface, location)| {
-        let location_clone = location.clone();
+        let location_clone = location;
         let surface_clone = surface.clone();
         PopupManager::popups_for_surface(surface.wl_surface()).map(move |(popup, popup_offset)| {
             let offset = (popup_offset - popup.geometry().loc).as_global();
@@ -383,11 +383,11 @@ fn layer_popups<'a>(
     })
 }
 
-fn layer_surfaces<'a>(
-    output: &'a Output,
+fn layer_surfaces(
+    output: &Output,
     layer: Layer,
     element_filter: ElementFilter,
-) -> impl Iterator<Item = (LayerSurface, Point<i32, Global>)> + 'a {
+) -> impl Iterator<Item = (LayerSurface, Point<i32, Global>)> + '_ {
     // we want to avoid deadlocks on the layer-map in callbacks, so we need to clone the layer surfaces
     let layers = {
         let layer_map = layer_map_for_output(output);
diff --git a/src/shell/focus/target.rs b/src/shell/focus/target.rs
index f4ea9884f..f084cb352 100644
--- a/src/shell/focus/target.rs
+++ b/src/shell/focus/target.rs
@@ -205,7 +205,7 @@ impl KeyboardFocusTarget {
         match self {
             KeyboardFocusTarget::Element(mapped) => mapped.wl_surface(),
             KeyboardFocusTarget::Popup(PopupKind::Xdg(xdg)) => {
-                get_popup_toplevel(&xdg).map(Cow::Owned)
+                get_popup_toplevel(xdg).map(Cow::Owned)
             }
             _ => None,
         }
@@ -278,7 +278,7 @@ impl IsAlive for KeyboardFocusTarget {
 
 impl PointerTarget<State> for PointerFocusTarget {
     fn enter(&self, seat: &Seat<State>, data: &mut State, event: &PointerMotionEvent) {
-        let toplevel = self.toplevel(&*data.common.shell.read());
+        let toplevel = self.toplevel(&data.common.shell.read());
         if let Some(element) = toplevel {
             for session in element.cursor_sessions() {
                 session.set_cursor_pos(Some(
@@ -300,7 +300,7 @@ impl PointerTarget<State> for PointerFocusTarget {
         self.inner_pointer_target().enter(seat, data, event);
     }
     fn motion(&self, seat: &Seat<State>, data: &mut State, event: &PointerMotionEvent) {
-        let toplevel = self.toplevel(&*data.common.shell.read());
+        let toplevel = self.toplevel(&data.common.shell.read());
         if let Some(element) = toplevel {
             for session in element.cursor_sessions() {
                 session.set_cursor_pos(Some(
@@ -335,7 +335,7 @@ impl PointerTarget<State> for PointerFocusTarget {
         self.inner_pointer_target().frame(seat, data);
     }
     fn leave(&self, seat: &Seat<State>, data: &mut State, serial: Serial, time: u32) {
-        let toplevel = self.toplevel(&*data.common.shell.read());
+        let toplevel = self.toplevel(&data.common.shell.read());
         if let Some(element) = toplevel {
             for session in element.cursor_sessions() {
                 session.set_cursor_pos(None);
diff --git a/src/shell/grabs/menu/default.rs b/src/shell/grabs/menu/default.rs
index e936b2f45..46c9df2ed 100644
--- a/src/shell/grabs/menu/default.rs
+++ b/src/shell/grabs/menu/default.rs
@@ -51,9 +51,7 @@ fn next_workspace(
     shell
         .workspaces
         .spaces_for_output(&output)
-        .skip_while(|space| space.handle != current_handle)
-        .skip(1)
-        .next()
+        .skip_while(|space| space.handle != current_handle).nth(1)
         .map(|space| (current_handle, space.handle))
 }
 
@@ -62,7 +60,7 @@ fn move_fullscreen_prev_workspace(state: &mut State, surface: &CosmicSurface) {
     let Some(wl_surface) = surface.wl_surface() else {
         return;
     };
-    let Some((from, to)) = prev_workspace(&shell, &*wl_surface) else {
+    let Some((from, to)) = prev_workspace(&shell, &wl_surface) else {
         return;
     };
 
@@ -88,7 +86,7 @@ fn move_fullscreen_next_workspace(state: &mut State, surface: &CosmicSurface) {
     let Some(wl_surface) = surface.wl_surface() else {
         return;
     };
-    let Some((from, to)) = next_workspace(&shell, &*wl_surface) else {
+    let Some((from, to)) = next_workspace(&shell, &wl_surface) else {
         return;
     };
 
@@ -115,7 +113,7 @@ fn move_element_prev_workspace(state: &mut State, mapped: &CosmicMapped) {
     let Some(wl_surface) = window.wl_surface() else {
         return;
     };
-    let Some((from, to)) = prev_workspace(&shell, &*wl_surface) else {
+    let Some((from, to)) = prev_workspace(&shell, &wl_surface) else {
         return;
     };
 
@@ -141,7 +139,7 @@ fn move_element_next_workspace(state: &mut State, mapped: &CosmicMapped) {
     let Some(wl_surface) = window.wl_surface() else {
         return;
     };
-    let Some((from, to)) = next_workspace(&shell, &*wl_surface) else {
+    let Some((from, to)) = next_workspace(&shell, &wl_surface) else {
         return;
     };
 
diff --git a/src/shell/grabs/menu/item.rs b/src/shell/grabs/menu/item.rs
index bf69e3ab4..d693814f0 100644
--- a/src/shell/grabs/menu/item.rs
+++ b/src/shell/grabs/menu/item.rs
@@ -40,7 +40,7 @@ struct State {
     cursor_over: bool,
 }
 
-impl<'a, Message> Widget<Message, cosmic::Theme, cosmic::Renderer> for SubmenuItem<'a, Message>
+impl<Message> Widget<Message, cosmic::Theme, cosmic::Renderer> for SubmenuItem<'_, Message>
 where
     Message: CursorEvents,
 {
@@ -216,11 +216,11 @@ where
     }
 }
 
-impl<'a, Message> Into<cosmic::Element<'a, Message>> for SubmenuItem<'a, Message>
+impl<'a, Message> From<SubmenuItem<'a, Message>> for cosmic::Element<'a, Message>
 where
     Message: CursorEvents + 'a,
 {
-    fn into(self) -> cosmic::Element<'a, Message> {
-        Element::new(self)
+    fn from(val: SubmenuItem<'a, Message>) -> Self {
+        Element::new(val)
     }
 }
diff --git a/src/shell/grabs/menu/mod.rs b/src/shell/grabs/menu/mod.rs
index 35b12ec99..4c549abd1 100644
--- a/src/shell/grabs/menu/mod.rs
+++ b/src/shell/grabs/menu/mod.rs
@@ -381,7 +381,7 @@ impl Program for ContextMenu {
             .row_width
             .lock()
             .unwrap()
-            .map(|size| Length::Fixed(size))
+            .map(Length::Fixed)
             .unwrap_or(Length::Shrink);
         let mode = match width {
             Length::Shrink => Length::Shrink,
@@ -968,8 +968,7 @@ impl MenuAlignment {
                         size,
                         AxisAlignment::Centered,
                         AxisAlignment::Corner(0),
-                    )
-                    .into_iter(),
+                    ),
                 )
                 .chain(
                     for_alignment(
@@ -977,8 +976,7 @@ impl MenuAlignment {
                         size,
                         AxisAlignment::Corner(0),
                         AxisAlignment::Centered,
-                    )
-                    .into_iter(),
+                    ),
                 )
                 .chain(
                     for_alignment(
@@ -986,15 +984,14 @@ impl MenuAlignment {
                         size,
                         AxisAlignment::Corner(0),
                         AxisAlignment::Corner(0),
-                    )
-                    .into_iter(),
+                    ),
                 )
                 .collect(),
                 (AxisAlignment::PreferCentered, y) => {
                     for_alignment(position, size, AxisAlignment::Centered, y)
                         .into_iter()
                         .chain(
-                            for_alignment(position, size, AxisAlignment::Corner(0), y).into_iter(),
+                            for_alignment(position, size, AxisAlignment::Corner(0), y),
                         )
                         .collect()
                 }
@@ -1002,7 +999,7 @@ impl MenuAlignment {
                     for_alignment(position, size, x, AxisAlignment::Centered)
                         .into_iter()
                         .chain(
-                            for_alignment(position, size, x, AxisAlignment::Corner(0)).into_iter(),
+                            for_alignment(position, size, x, AxisAlignment::Corner(0)),
                         )
                         .collect()
                 }
diff --git a/src/shell/grabs/mod.rs b/src/shell/grabs/mod.rs
index def21cfea..91741e33d 100644
--- a/src/shell/grabs/mod.rs
+++ b/src/shell/grabs/mod.rs
@@ -122,9 +122,9 @@ impl From<shortcuts::action::ResizeEdge> for ResizeEdge {
     }
 }
 
-impl Into<shortcuts::action::ResizeEdge> for ResizeEdge {
-    fn into(self) -> shortcuts::action::ResizeEdge {
-        match self {
+impl From<ResizeEdge> for shortcuts::action::ResizeEdge {
+    fn from(val: ResizeEdge) -> Self {
+        match val {
             ResizeEdge::BOTTOM => shortcuts::action::ResizeEdge::Bottom,
             ResizeEdge::BOTTOM_LEFT => shortcuts::action::ResizeEdge::BottomLeft,
             ResizeEdge::BOTTOM_RIGHT => shortcuts::action::ResizeEdge::BottomRight,
diff --git a/src/shell/grabs/moving.rs b/src/shell/grabs/moving.rs
index 4a135e521..a5bf5b6a4 100644
--- a/src/shell/grabs/moving.rs
+++ b/src/shell/grabs/moving.rs
@@ -92,11 +92,10 @@ impl MoveGrabState {
 
         let mut window_geo = self.window.geometry();
         window_geo.loc += self.location.to_i32_round() + self.window_offset;
-        if !output
+        if output
             .geometry()
             .as_logical()
-            .intersection(window_geo)
-            .is_some()
+            .intersection(window_geo).is_none()
         {
             return Vec::new();
         }
@@ -136,15 +135,14 @@ impl MoveGrabState {
                         active_window_hint.green,
                         active_window_hint.blue,
                     ],
-                ))
-                .into(),
+                )),
             )
         } else {
             None
         };
 
         let non_exclusive_geometry = {
-            let layers = layer_map_for_output(&output);
+            let layers = layer_map_for_output(output);
             layers.non_exclusive_zone()
         };
 
@@ -173,8 +171,7 @@ impl MoveGrabState {
                             active_window_hint.green,
                             active_window_hint.blue,
                         ],
-                    ))
-                    .into(),
+                    )),
                     CosmicMappedRenderElement::from(BackdropShader::element(
                         renderer,
                         Key::Window(Usage::SnappingIndicator, self.window.key()),
@@ -182,8 +179,7 @@ impl MoveGrabState {
                         theme.radius_s()[0], // TODO: Fix once shaders support 4 corner radii customization
                         0.4,
                         [base_color.red, base_color.green, base_color.blue],
-                    ))
-                    .into(),
+                    )),
                 ]
             }
             _ => vec![],
@@ -431,7 +427,7 @@ impl MoveGrab {
                             indicator.output_enter(output, overlap);
                         }
                     }
-                } else if self.window_outputs.remove(&output) {
+                } else if self.window_outputs.remove(output) {
                     self.window.output_leave(output);
                     if let Some(indicator) = grab_state.stacking_indicator.as_ref().map(|x| &x.0) {
                         indicator.output_leave(output);
@@ -440,7 +436,7 @@ impl MoveGrab {
             }
 
             let indicator_location =
-                shell.stacking_indicator(&current_output, self.previous.clone());
+                shell.stacking_indicator(&current_output, self.previous);
             if indicator_location.is_some() != grab_state.stacking_indicator.is_some() {
                 grab_state.stacking_indicator = indicator_location.map(|geo| {
                     let element = stack_hover(
@@ -739,7 +735,7 @@ impl MoveGrab {
             start: Instant::now(),
             stacking_indicator: None,
             snapping_zone: None,
-            previous: previous_layer.clone(),
+            previous: previous_layer,
             location: start_data.location(),
             cursor_output: cursor_output.clone(),
         };
@@ -787,7 +783,7 @@ impl Drop for MoveGrab {
         let output = self.cursor_output.clone();
         let seat = self.seat.clone();
         let window_outputs = self.window_outputs.drain().collect::<HashSet<_>>();
-        let previous = self.previous.clone();
+        let previous = self.previous;
         let window = self.window.clone();
         let is_touch_grab = matches!(self.start_data, GrabStartData::Touch(_));
 
diff --git a/src/shell/layout/floating/grabs/resize.rs b/src/shell/layout/floating/grabs/resize.rs
index 6308ada80..2d1538616 100644
--- a/src/shell/layout/floating/grabs/resize.rs
+++ b/src/shell/layout/floating/grabs/resize.rs
@@ -101,22 +101,18 @@ impl ResizeSurfaceGrab {
             // If the resizing vertical edge is close to our output's edge in the same direction, snap to it.
             let output_geom = self.output.geometry().to_local(&self.output);
             if self.edges.intersects(ResizeEdge::LEFT) {
-                if ((self.initial_window_location.x - dx as i32 - output_geom.loc.x).abs() as u32)
+                if (self.initial_window_location.x - dx as i32 - output_geom.loc.x).unsigned_abs()
                     < self.edge_snap_threshold
                 {
                     new_window_width = self.initial_window_size.w - output_geom.loc.x
                         + self.initial_window_location.x;
                 }
-            } else {
-                if ((self.initial_window_location.x + self.initial_window_size.w + dx as i32
-                    - output_geom.loc.x
-                    - output_geom.size.w)
-                    .abs() as u32)
-                    < self.edge_snap_threshold
-                {
-                    new_window_width =
-                        output_geom.loc.x - self.initial_window_location.x + output_geom.size.w;
-                }
+            } else if (self.initial_window_location.x + self.initial_window_size.w + dx as i32
+                - output_geom.loc.x - output_geom.size.w).unsigned_abs()
+                < self.edge_snap_threshold
+            {
+                new_window_width =
+                    output_geom.loc.x - self.initial_window_location.x + output_geom.size.w;
             }
         }
 
@@ -131,22 +127,18 @@ impl ResizeSurfaceGrab {
             // If the resizing horizontal edge is close to our output's edge in the same direction, snap to it.
             let output_geom = self.output.geometry().to_local(&self.output);
             if self.edges.intersects(ResizeEdge::TOP) {
-                if ((self.initial_window_location.y - dy as i32 - output_geom.loc.y).abs() as u32)
+                if (self.initial_window_location.y - dy as i32 - output_geom.loc.y).unsigned_abs()
                     < self.edge_snap_threshold
                 {
                     new_window_height = self.initial_window_size.h - output_geom.loc.y
                         + self.initial_window_location.y;
                 }
-            } else {
-                if ((self.initial_window_location.y + self.initial_window_size.h + dy as i32
-                    - output_geom.loc.y
-                    - output_geom.size.h)
-                    .abs() as u32)
-                    < self.edge_snap_threshold
-                {
-                    new_window_height =
-                        output_geom.loc.y - self.initial_window_location.y + output_geom.size.h;
-                }
+            } else if (self.initial_window_location.y + self.initial_window_size.h + dy as i32
+                - output_geom.loc.y - output_geom.size.h).unsigned_abs()
+                < self.edge_snap_threshold
+            {
+                new_window_height =
+                    output_geom.loc.y - self.initial_window_location.y + output_geom.size.h;
             }
         }
 
@@ -361,10 +353,8 @@ impl TouchGrab<State> for ResizeSurfaceGrab {
         event: &TouchMotionEvent,
         seq: Serial,
     ) {
-        if event.slot == <Self as TouchGrab<State>>::start_data(self).slot {
-            if self.update_location(event.location.as_global()) {
-                handle.unset_grab(self, data);
-            }
+        if event.slot == <Self as TouchGrab<State>>::start_data(self).slot && self.update_location(event.location.as_global()) {
+            handle.unset_grab(self, data);
         }
 
         handle.motion(data, None, event, seq);
@@ -514,7 +504,7 @@ impl ResizeSurfaceGrab {
 
                     if edges.intersects(ResizeEdge::TOP_LEFT) {
                         let size = window.geometry().size;
-                        let mut new = location.clone();
+                        let mut new = location;
                         if edges.intersects(ResizeEdge::LEFT) {
                             new.x = initial_window_location.x + (initial_window_size.w - size.w);
                         }
@@ -555,7 +545,7 @@ impl ResizeSurfaceGrab {
                 }
                 floating_layer.space.map_element(
                     window,
-                    new_location.to_local(&output).as_logical(),
+                    new_location.to_local(output).as_logical(),
                     false,
                 );
             }
diff --git a/src/shell/layout/floating/mod.rs b/src/shell/layout/floating/mod.rs
index 2586f630c..44648e1ae 100644
--- a/src/shell/layout/floating/mod.rs
+++ b/src/shell/layout/floating/mod.rs
@@ -137,7 +137,7 @@ impl Animation {
             }
             | Animation::Unminimize {
                 target_geometry, ..
-            } => (MINIMIZE_ANIMATION_DURATION, target_geometry.clone()),
+            } => (MINIMIZE_ANIMATION_DURATION, *target_geometry),
             Animation::Tiled { .. } => {
                 let target_geometry = if let Some(target_rect) =
                     tiled_state.map(|state| state.relative_geometry(output_geometry, gaps))
@@ -149,7 +149,7 @@ impl Animation {
                 (ANIMATION_DURATION, target_geometry)
             }
         };
-        let previous_rect = self.previous_geometry().clone();
+        let previous_rect = *self.previous_geometry();
         let start = *self.start();
         let now = Instant::now();
         let progress =
@@ -284,7 +284,7 @@ impl FloatingLayout {
         }
         .to_f64();
         let output_geometry = {
-            let layers = layer_map_for_output(&output);
+            let layers = layer_map_for_output(output);
             layers.non_exclusive_zone()
         };
 
@@ -295,7 +295,7 @@ impl FloatingLayout {
             .collect::<Vec<_>>()
             .into_iter()
         {
-            let tiled_state = mapped.floating_tiled.lock().unwrap().clone();
+            let tiled_state = *mapped.floating_tiled.lock().unwrap();
             if let Some(tiled_state) = tiled_state {
                 let geometry = tiled_state.relative_geometry(output_geometry, self.gaps());
                 self.map_internal(
@@ -383,7 +383,7 @@ impl FloatingLayout {
         }
         if mapped.floating_tiled.lock().unwrap().take().is_some() {
             if let Some(state) = mapped.maximized_state.lock().unwrap().as_mut() {
-                if let Some(real_old_geo) = mapped.last_geometry.lock().unwrap().clone() {
+                if let Some(real_old_geo) = *mapped.last_geometry.lock().unwrap() {
                     state.original_geometry = real_old_geo;
                 }
             };
@@ -407,7 +407,7 @@ impl FloatingLayout {
         let layers = layer_map_for_output(&output);
         let output_geometry = layers.non_exclusive_zone();
         mapped.set_bounds(output_geometry.size);
-        let last_geometry = mapped.last_geometry.lock().unwrap().clone();
+        let last_geometry = *mapped.last_geometry.lock().unwrap();
         let min_size = mapped.min_size().unwrap_or((320, 240).into());
 
         if let Some(size) = size
@@ -688,7 +688,7 @@ impl FloatingLayout {
             *window.last_geometry.lock().unwrap() = Some(mapped_geometry);
         }
 
-        self.space.unmap_elem(&window);
+        self.space.unmap_elem(window);
         if let Some(pos) = self.spawn_order.iter().position(|w| w == window) {
             self.spawn_order.truncate(pos);
         }
@@ -877,7 +877,7 @@ impl FloatingLayout {
     }
 
     pub fn stacking_indicator(&self) -> Option<Rectangle<i32, Local>> {
-        self.hovered_stack.as_ref().map(|(_, geo)| geo.clone())
+        self.hovered_stack.as_ref().map(|(_, geo)| *geo)
     }
 
     pub fn resize_request(
@@ -890,7 +890,7 @@ impl FloatingLayout {
         release: ReleaseMode,
     ) -> Option<ResizeSurfaceGrab> {
         if seat.get_pointer().is_some() {
-            let location = self.space.element_location(&mapped)?.as_local();
+            let location = self.space.element_location(mapped)?.as_local();
             let size = mapped.geometry().size;
             mapped.moved_since_mapped.store(true, Ordering::SeqCst);
 
@@ -934,7 +934,7 @@ impl FloatingLayout {
         let Some(original_geo) = self.space.element_geometry(mapped) else {
             return false; // we don't have that window
         };
-        let mut geo = original_geo.clone();
+        let mut geo = original_geo;
 
         if edge.contains(ResizeEdge::RIGHT) || edge.contains(ResizeEdge::LEFT) {
             if direction == ResizeDirection::Inwards {
@@ -1313,7 +1313,7 @@ impl FloatingLayout {
             let window_geometry = if mapped.is_maximized(false) {
                 geometry
             } else {
-                prev.clone()
+                prev
                     .map(|mut rect| {
                         if let Some(old_size) = old_output_size {
                             rect = Rectangle::new(
@@ -1529,14 +1529,14 @@ impl FloatingLayout {
                                         .to_physical_precise_round(output_scale),
                                     scale,
                                 );
-                                let relocated = RelocateRenderElement::from_element(
+                                
+                                RelocateRenderElement::from_element(
                                     rescaled,
                                     (geometry.loc - original_geo.loc)
                                         .as_logical()
                                         .to_physical_precise_round(output_scale),
                                     Relocate::Relative,
-                                );
-                                relocated
+                                )
                             })
                         }
                         CosmicMappedRenderElement::Window(elem) => {
@@ -1549,14 +1549,14 @@ impl FloatingLayout {
                                         .to_physical_precise_round(output_scale),
                                     scale,
                                 );
-                                let relocated = RelocateRenderElement::from_element(
+                                
+                                RelocateRenderElement::from_element(
                                     rescaled,
                                     (geometry.loc - original_geo.loc)
                                         .as_logical()
                                         .to_physical_precise_round(output_scale),
                                     Relocate::Relative,
-                                );
-                                relocated
+                                )
                             })
                         }
                         x => x,
@@ -1566,7 +1566,7 @@ impl FloatingLayout {
 
             if focused == Some(elem) && !elem.is_maximized(false) {
                 if let Some((mode, resize)) = resize_indicator.as_mut() {
-                    let mut resize_geometry = geometry.clone();
+                    let mut resize_geometry = geometry;
                     resize_geometry.loc -= (18, 18).into();
                     resize_geometry.size += (36, 36).into();
 
diff --git a/src/shell/layout/tiling/grabs/resize.rs b/src/shell/layout/tiling/grabs/resize.rs
index 520624271..db035c5bf 100644
--- a/src/shell/layout/tiling/grabs/resize.rs
+++ b/src/shell/layout/tiling/grabs/resize.rs
@@ -535,10 +535,8 @@ impl TouchGrab<State> for ResizeForkGrab {
         event: &TouchMotionEvent,
         seq: Serial,
     ) {
-        if event.slot == <Self as TouchGrab<State>>::start_data(self).slot {
-            if self.update_location(data, event.location, false) {
-                handle.unset_grab(self, data);
-            }
+        if event.slot == <Self as TouchGrab<State>>::start_data(self).slot && self.update_location(data, event.location, false) {
+            handle.unset_grab(self, data);
         }
 
         handle.motion(data, None, event, seq);
diff --git a/src/shell/layout/tiling/grabs/swap.rs b/src/shell/layout/tiling/grabs/swap.rs
index 82e8452e8..f603f9d20 100644
--- a/src/shell/layout/tiling/grabs/swap.rs
+++ b/src/shell/layout/tiling/grabs/swap.rs
@@ -49,7 +49,7 @@ impl KeyboardGrab<State> for SwapWindowGrab {
             return;
         }
 
-        let syms = Vec::from(handle.keysym_handle(keycode).raw_syms());
+        let syms = handle.keysym_handle(keycode).raw_syms();
         let focus_bindings = &data
             .common
             .config
diff --git a/src/shell/layout/tiling/mod.rs b/src/shell/layout/tiling/mod.rs
index 1ede14b04..7f7fb9263 100644
--- a/src/shell/layout/tiling/mod.rs
+++ b/src/shell/layout/tiling/mod.rs
@@ -500,7 +500,7 @@ impl TilingLayout {
 
             if sibling
                 .as_ref()
-                .is_some_and(|sibling| tree.get(&sibling).is_ok())
+                .is_some_and(|sibling| tree.get(sibling).is_ok())
             {
                 let sibling_id = sibling.unwrap();
                 let new_node = Node::new(Data::Mapped {
@@ -542,7 +542,7 @@ impl TilingLayout {
     }
 
     fn map_to_tree(
-        mut tree: &mut Tree<Data>,
+        tree: &mut Tree<Data>,
         window: impl Into<CosmicMapped>,
         output: &Output,
         node: Option<NodeId>,
@@ -564,7 +564,7 @@ impl TilingLayout {
                 };
 
                 let new_id = tree.insert(new_window, InsertBehavior::AsRoot).unwrap();
-                TilingLayout::new_group(&mut tree, &root_id, &new_id, orientation).unwrap();
+                TilingLayout::new_group(tree, &root_id, &new_id, orientation).unwrap();
                 tree.make_nth_sibling(
                     &new_id,
                     match direction {
@@ -577,36 +577,34 @@ impl TilingLayout {
             } else {
                 tree.insert(new_window, InsertBehavior::AsRoot).unwrap()
             }
+        } else if let Some(ref node_id) = node {
+            let orientation = {
+                let window_size = tree.get(node_id).unwrap().data().geometry().size;
+                if window_size.w > window_size.h {
+                    Orientation::Vertical
+                } else {
+                    Orientation::Horizontal
+                }
+            };
+            let new_id = tree.insert(new_window, InsertBehavior::AsRoot).unwrap();
+            TilingLayout::new_group(tree, node_id, &new_id, orientation).unwrap();
+            new_id
         } else {
-            if let Some(ref node_id) = node {
+            // nothing? then we add to the root
+            if let Some(root_id) = tree.root_node_id().cloned() {
                 let orientation = {
-                    let window_size = tree.get(node_id).unwrap().data().geometry().size;
-                    if window_size.w > window_size.h {
+                    let output_size = output.geometry().size;
+                    if output_size.w > output_size.h {
                         Orientation::Vertical
                     } else {
                         Orientation::Horizontal
                     }
                 };
                 let new_id = tree.insert(new_window, InsertBehavior::AsRoot).unwrap();
-                TilingLayout::new_group(&mut tree, &node_id, &new_id, orientation).unwrap();
+                TilingLayout::new_group(tree, &root_id, &new_id, orientation).unwrap();
                 new_id
             } else {
-                // nothing? then we add to the root
-                if let Some(root_id) = tree.root_node_id().cloned() {
-                    let orientation = {
-                        let output_size = output.geometry().size;
-                        if output_size.w > output_size.h {
-                            Orientation::Vertical
-                        } else {
-                            Orientation::Horizontal
-                        }
-                    };
-                    let new_id = tree.insert(new_window, InsertBehavior::AsRoot).unwrap();
-                    TilingLayout::new_group(&mut tree, &root_id, &new_id, orientation).unwrap();
-                    new_id
-                } else {
-                    tree.insert(new_window, InsertBehavior::AsRoot).unwrap()
-                }
+                tree.insert(new_window, InsertBehavior::AsRoot).unwrap()
             }
         };
 
@@ -666,7 +664,7 @@ impl TilingLayout {
                 let this_stack = this_mapped.stack_ref()?;
                 this_stack.remove_window(&stack_surface);
                 if !this_stack.alive() {
-                    let _ = this.unmap(&this_mapped, None);
+                    let _ = this.unmap(this_mapped, None);
                 }
 
                 let mapped: CosmicMapped =
@@ -687,13 +685,13 @@ impl TilingLayout {
 
                 mapped.set_tiled(true);
                 other.map(mapped.clone(), Some(focus_stack), direction);
-                return Some(KeyboardFocusTarget::Element(mapped));
+                Some(KeyboardFocusTarget::Element(mapped))
             }
             None => {
                 let node = this_tree.get(&desc.node).ok()?;
                 let mut children = node
                     .children()
-                    .into_iter()
+                    .iter()
                     .map(|child_id| (desc.node.clone(), child_id.clone()))
                     .collect::<Vec<_>>();
                 let node = Node::new(node.data().clone());
@@ -819,7 +817,7 @@ impl TilingLayout {
                     .push_tree(other_tree, ANIMATION_DURATION, blocker);
 
                 other.node_desc_to_focus(&NodeDesc {
-                    handle: other_handle.clone(),
+                    handle: *other_handle,
                     node: id.clone(),
                     stack_window: None,
                     focus_stack: Vec::new(), // node_desc_to_focus doesn't use this
@@ -915,12 +913,12 @@ impl TilingLayout {
                 // swap children
                 let mut this_children = this_node
                     .children()
-                    .into_iter()
+                    .iter()
                     .map(|child_id| (other_desc.node.clone(), child_id.clone()))
                     .collect::<Vec<_>>();
                 let mut other_children = other_node
                     .children()
-                    .into_iter()
+                    .iter()
                     .map(|child_id| (this_desc.node.clone(), child_id.clone()))
                     .collect::<Vec<_>>();
 
@@ -1070,7 +1068,7 @@ impl TilingLayout {
                     toplevel_leave_workspace(this_surface, &this_desc.handle);
                     toplevel_enter_workspace(this_surface, &other_desc.handle);
                 }
-                this_stack.remove_window(&this_surface);
+                this_stack.remove_window(this_surface);
 
                 let mapped: CosmicMapped = CosmicWindow::new(
                     this_surface.clone(),
@@ -1157,7 +1155,7 @@ impl TilingLayout {
                     toplevel_leave_workspace(other_surface, &other_desc.handle);
                     toplevel_enter_workspace(other_surface, &this_desc.handle);
                 }
-                other_stack.remove_window(&other_surface);
+                other_stack.remove_window(other_surface);
 
                 let mapped: CosmicMapped = CosmicWindow::new(
                     other_surface.clone(),
@@ -1266,12 +1264,12 @@ impl TilingLayout {
         }
 
         match (&this_desc.stack_window, &other_desc.stack_window) {
-            (None, None) if !has_other_tree => this.node_desc_to_focus(&this_desc),
+            (None, None) if !has_other_tree => this.node_desc_to_focus(this_desc),
             //(None, Some(_)) => None,
             _ => other
                 .as_ref()
                 .unwrap_or(&this)
-                .node_desc_to_focus(&other_desc),
+                .node_desc_to_focus(other_desc),
         }
     }
 
@@ -1311,7 +1309,7 @@ impl TilingLayout {
         let state = {
             let tree = &self.queue.trees.back().unwrap().0;
             tree.get(&node_id).unwrap().parent().and_then(|parent_id| {
-                let parent = tree.get(&parent_id).unwrap();
+                let parent = tree.get(parent_id).unwrap();
                 let idx = parent
                     .children()
                     .iter()
@@ -1325,7 +1323,7 @@ impl TilingLayout {
                         // this group will be flattened
                         Some(RestoreTilingState {
                             parent: None,
-                            sibling: parent.children().iter().cloned().find(|id| id != &node_id),
+                            sibling: parent.children().iter().find(|&id| id != &node_id).cloned(),
                             orientation: *orientation,
                             idx,
                             sizes: sizes.clone(),
@@ -1390,7 +1388,7 @@ impl TilingLayout {
             .data_mut();
         *data = Data::Placeholder {
             id: Id::new(),
-            last_geometry: data.geometry().clone(),
+            last_geometry: *data.geometry(),
             type_,
         };
 
@@ -1435,7 +1433,7 @@ impl TilingLayout {
     fn unmap_internal(tree: &mut Tree<Data>, node: &NodeId) {
         let parent_id = tree.get(node).ok().and_then(|node| node.parent()).cloned();
         let position = parent_id.as_ref().and_then(|parent_id| {
-            tree.children_ids(&parent_id)
+            tree.children_ids(parent_id)
                 .unwrap()
                 .position(|id| id == node)
         });
@@ -1470,7 +1468,7 @@ impl TilingLayout {
                         &other_child,
                         parent_parent_id
                             .as_ref()
-                            .map(|parent_id| MoveBehavior::ToParent(parent_id))
+                            .map(MoveBehavior::ToParent)
                             .unwrap_or(MoveBehavior::ToRoot),
                     )
                     .unwrap();
@@ -1736,9 +1734,7 @@ impl TilingLayout {
                                 // we move again by making a new fork
                                 let old_id = tree
                                     .children_ids(&next_child_id)
-                                    .unwrap()
-                                    .skip(group_len / 2)
-                                    .next()
+                                    .unwrap().nth(group_len / 2)
                                     .unwrap()
                                     .clone();
                                 TilingLayout::new_group(
@@ -1887,7 +1883,7 @@ impl TilingLayout {
         let mut node_id = last_node_id.clone();
         while let Some(group) = tree.get(&node_id).unwrap().parent() {
             let child = node_id.clone();
-            let group_data = tree.get(&group).unwrap().data();
+            let group_data = tree.get(group).unwrap().data();
             let main_orientation = group_data.orientation();
             assert!(group_data.is_group());
 
@@ -1908,7 +1904,7 @@ impl TilingLayout {
                     WindowGroup {
                         node: group.clone(),
                         alive: match group_data {
-                            &Data::Group { ref alive, .. } => Arc::downgrade(alive),
+                            Data::Group { alive, .. } => Arc::downgrade(alive),
                             _ => unreachable!(),
                         },
                         focus_stack: match data {
@@ -1925,7 +1921,7 @@ impl TilingLayout {
 
             // which child are we?
             let idx = tree
-                .children_ids(&group)
+                .children_ids(group)
                 .unwrap()
                 .position(|id| id == &child)
                 .unwrap();
@@ -1936,13 +1932,13 @@ impl TilingLayout {
                 | (Orientation::Vertical, FocusDirection::Right)
                     if idx < (len - 1) =>
                 {
-                    tree.children_ids(&group).unwrap().skip(idx + 1).next()
+                    tree.children_ids(group).unwrap().nth(idx + 1)
                 }
                 (Orientation::Horizontal, FocusDirection::Up)
                 | (Orientation::Vertical, FocusDirection::Left)
                     if idx > 0 =>
                 {
-                    tree.children_ids(&group).unwrap().skip(idx - 1).next()
+                    tree.children_ids(group).unwrap().nth(idx - 1)
                 }
                 _ => None, // continue iterating
             };
@@ -1965,7 +1961,7 @@ impl TilingLayout {
                                 Data::Group { alive, .. } => {
                                     FocusResult::Some(KeyboardFocusTarget::Group(WindowGroup {
                                         node: replacement_id.clone(),
-                                        alive: Arc::downgrade(&alive),
+                                        alive: Arc::downgrade(alive),
                                         focus_stack: tree
                                             .children_ids(replacement_id)
                                             .unwrap()
@@ -2653,7 +2649,7 @@ impl TilingLayout {
         }
 
         let mapped = match self.last_overview_hover.as_ref().map(|x| &x.1) {
-            Some(TargetZone::GroupEdge(group_id, direction)) if tree.get(&group_id).is_ok() => {
+            Some(TargetZone::GroupEdge(group_id, direction)) if tree.get(group_id).is_ok() => {
                 let new_id = tree
                     .insert(
                         Node::new(Data::Mapped {
@@ -2671,7 +2667,7 @@ impl TilingLayout {
                     Orientation::Horizontal
                 };
                 if tree.get(group_id).unwrap().data().orientation() != orientation {
-                    TilingLayout::new_group(&mut tree, &group_id, &new_id, orientation).unwrap();
+                    TilingLayout::new_group(&mut tree, group_id, &new_id, orientation).unwrap();
                 } else {
                     let data = tree.get_mut(group_id).unwrap().data_mut();
                     let len = data.len();
@@ -2689,7 +2685,7 @@ impl TilingLayout {
                 *window.tiling_node_id.lock().unwrap() = Some(new_id);
                 window
             }
-            Some(TargetZone::GroupInterior(group_id, idx)) if tree.get(&group_id).is_ok() => {
+            Some(TargetZone::GroupInterior(group_id, idx)) if tree.get(group_id).is_ok() => {
                 let new_id = tree
                     .insert(
                         Node::new(Data::Mapped {
@@ -2710,9 +2706,9 @@ impl TilingLayout {
                 *window.tiling_node_id.lock().unwrap() = Some(new_id);
                 window
             }
-            Some(TargetZone::InitialPlaceholder(node_id)) if tree.get(&node_id).is_ok() => {
-                let data = tree.get_mut(&node_id).unwrap().data_mut();
-                let geo = data.geometry().clone();
+            Some(TargetZone::InitialPlaceholder(node_id)) if tree.get(node_id).is_ok() => {
+                let data = tree.get_mut(node_id).unwrap().data_mut();
+                let geo = *data.geometry();
 
                 *data = Data::Mapped {
                     mapped: window.clone(),
@@ -2722,7 +2718,7 @@ impl TilingLayout {
                 *window.tiling_node_id.lock().unwrap() = Some(node_id.clone());
                 window
             }
-            Some(TargetZone::WindowSplit(window_id, direction)) if tree.get(&window_id).is_ok() => {
+            Some(TargetZone::WindowSplit(window_id, direction)) if tree.get(window_id).is_ok() => {
                 let new_id = tree
                     .insert(
                         Node::new(Data::Mapped {
@@ -2730,7 +2726,7 @@ impl TilingLayout {
                             last_geometry: Rectangle::from_size((100, 100).into()),
                             minimize_rect: None,
                         }),
-                        InsertBehavior::UnderNode(&window_id),
+                        InsertBehavior::UnderNode(window_id),
                     )
                     .unwrap();
                 let orientation = if matches!(direction, Direction::Left | Direction::Right) {
@@ -2738,14 +2734,14 @@ impl TilingLayout {
                 } else {
                     Orientation::Horizontal
                 };
-                TilingLayout::new_group(&mut tree, &window_id, &new_id, orientation).unwrap();
+                TilingLayout::new_group(&mut tree, window_id, &new_id, orientation).unwrap();
                 if matches!(direction, Direction::Left | Direction::Up) {
                     tree.make_first_sibling(&new_id).unwrap();
                 }
                 *window.tiling_node_id.lock().unwrap() = Some(new_id.clone());
                 window
             }
-            Some(TargetZone::WindowStack(window_id, _)) if tree.get(&window_id).is_ok() => {
+            Some(TargetZone::WindowStack(window_id, _)) if tree.get(window_id).is_ok() => {
                 match tree.get_mut(window_id).unwrap().data_mut() {
                     Data::Mapped { mapped, .. } => {
                         mapped.convert_to_stack((&self.output, mapped.bbox()), self.theme.clone());
@@ -2978,7 +2974,7 @@ impl TilingLayout {
             let mut configures = Vec::new();
 
             let (outer, inner) = gaps;
-            let mut geo = layer_map_for_output(&output)
+            let mut geo = layer_map_for_output(output)
                 .non_exclusive_zone()
                 .as_local();
             geo.loc.x += outer;
@@ -3095,7 +3091,7 @@ impl TilingLayout {
                         Data::Mapped { mapped, .. } => {
                             if !(mapped.is_fullscreen(true) || mapped.is_maximized(true)) {
                                 mapped.set_tiled(true);
-                                let internal_geometry = geo.to_global(&output);
+                                let internal_geometry = geo.to_global(output);
                                 mapped.set_geometry(internal_geometry);
                                 if let Some(serial) = mapped.configure() {
                                     configures.push((mapped.active_window(), serial));
@@ -3312,9 +3308,7 @@ impl TilingLayout {
                         (last_geometry.loc
                             + tree
                                 .children(&id)
-                                .unwrap()
-                                .skip(idx)
-                                .next()
+                                .unwrap().nth(idx)
                                 .map(|node| {
                                     let geo = node.data().geometry();
                                     geo.loc + geo.size
@@ -3647,7 +3641,7 @@ impl TilingLayout {
                                     } => true,
                                     _ => false,
                                 })
-                                .map(|node_id| TargetZone::InitialPlaceholder(node_id))
+                                .map(TargetZone::InitialPlaceholder)
                                 .unwrap_or(TargetZone::Initial),
                         ));
                     }
@@ -3684,14 +3678,14 @@ impl TilingLayout {
                                 let removed = if let TargetZone::InitialPlaceholder(node_id) =
                                     old_target_zone
                                 {
-                                    if tree.get(&node_id).is_ok() {
-                                        TilingLayout::unmap_internal(&mut tree, &node_id);
+                                    if tree.get(node_id).is_ok() {
+                                        TilingLayout::unmap_internal(&mut tree, node_id);
                                     }
                                     true
                                 } else if let TargetZone::WindowSplit(node_id, _) = old_target_zone
                                 {
                                     if let Some(children) = tree
-                                        .get(&node_id)
+                                        .get(node_id)
                                         .ok()
                                         .and_then(|node| node.parent())
                                         .and_then(|parent_id| tree.get(parent_id).ok())
@@ -3714,7 +3708,7 @@ impl TilingLayout {
                                     }
                                     true
                                 } else if let TargetZone::GroupEdge(node_id, _) = old_target_zone {
-                                    if let Ok(node) = tree.get_mut(&node_id) {
+                                    if let Ok(node) = tree.get_mut(node_id) {
                                         match node.data_mut() {
                                             Data::Group { pill_indicator, .. } => {
                                                 *pill_indicator = None;
@@ -3726,7 +3720,7 @@ impl TilingLayout {
                                 } else if let TargetZone::GroupInterior(node_id, _) =
                                     old_target_zone
                                 {
-                                    if let Ok(node) = tree.get_mut(&node_id) {
+                                    if let Ok(node) = tree.get_mut(node_id) {
                                         match node.data_mut() {
                                             Data::Group { pill_indicator, .. } => {
                                                 *pill_indicator = None;
@@ -3761,7 +3755,7 @@ impl TilingLayout {
                                         } else {
                                             Orientation::Horizontal
                                         };
-                                    TilingLayout::new_group(&mut tree, &node_id, &id, orientation)
+                                    TilingLayout::new_group(&mut tree, node_id, &id, orientation)
                                         .unwrap();
                                     if matches!(dir, Direction::Left | Direction::Up) {
                                         tree.make_first_sibling(&id).unwrap();
@@ -3771,7 +3765,7 @@ impl TilingLayout {
                                 } else if let TargetZone::GroupEdge(node_id, direction) =
                                     &target_zone
                                 {
-                                    if let Ok(node) = tree.get_mut(&node_id) {
+                                    if let Ok(node) = tree.get_mut(node_id) {
                                         match node.data_mut() {
                                             Data::Group { pill_indicator, .. } => {
                                                 *pill_indicator =
@@ -3785,7 +3779,7 @@ impl TilingLayout {
                                     }
                                 } else if let TargetZone::GroupInterior(node_id, idx) = &target_zone
                                 {
-                                    if let Ok(node) = tree.get_mut(&node_id) {
+                                    if let Ok(node) = tree.get_mut(node_id) {
                                         match node.data_mut() {
                                             Data::Group { pill_indicator, .. } => {
                                                 *pill_indicator = Some(PillIndicator::Inner(*idx));
@@ -3823,9 +3817,7 @@ impl TilingLayout {
 
     pub fn mapped(&self) -> impl Iterator<Item = (&CosmicMapped, Rectangle<i32, Local>)> {
         let tree = &self.queue.trees.back().unwrap().0;
-        let iter = if let Some(root) = tree.root_node_id() {
-            Some(
-                tree.traverse_pre_order(root)
+        let iter = tree.root_node_id().map(|root| tree.traverse_pre_order(root)
                     .unwrap()
                     .filter(|node| node.data().is_mapped(None))
                     .filter(|node| match node.data() {
@@ -3837,7 +3829,7 @@ impl TilingLayout {
                             mapped,
                             last_geometry,
                             ..
-                        } => (mapped, last_geometry.clone()),
+                        } => (mapped, *last_geometry),
                         _ => unreachable!(),
                     })
                     .chain(
@@ -3853,14 +3845,10 @@ impl TilingLayout {
                                     mapped,
                                     last_geometry,
                                     ..
-                                } => (mapped, last_geometry.clone()),
+                                } => (mapped, *last_geometry),
                                 _ => unreachable!(),
                             }),
-                    ),
-            )
-        } else {
-            None
-        };
+                    ));
         iter.into_iter().flatten()
     }
 
@@ -3868,7 +3856,7 @@ impl TilingLayout {
         self.mapped().flat_map(|(mapped, geo)| {
             mapped.windows().map(move |(w, p)| {
                 (w, {
-                    let mut geo = geo.clone();
+                    let mut geo = geo;
                     geo.loc += p.as_local();
                     geo.size -= p.to_size().as_local();
                     geo
@@ -3933,7 +3921,7 @@ impl TilingLayout {
 
             while let Some((src_id, dst_id)) = stack.pop() {
                 for child_id in src.children_ids(&src_id).unwrap() {
-                    let src_node = src.get(&child_id).unwrap();
+                    let src_node = src.get(child_id).unwrap();
                     let new_node = Node::new(src_node.data().clone());
                     let new_child_id = dst
                         .insert(new_node, InsertBehavior::UnderNode(&dst_id))
@@ -4027,7 +4015,7 @@ impl TilingLayout {
                     &self.backdrop_id,
                     is_mouse_tiling,
                     swap_desc.clone(),
-                    overview.1.as_ref().and_then(|(_, tree)| tree.clone()),
+                    overview.1.as_ref().and_then(|(_, tree)| *tree),
                     theme,
                 ))
             } else {
@@ -4064,7 +4052,7 @@ impl TilingLayout {
                 &self.backdrop_id,
                 is_mouse_tiling,
                 swap_desc.clone(),
-                overview.1.as_ref().and_then(|(_, tree)| tree.clone()),
+                overview.1.as_ref().and_then(|(_, tree)| *tree),
                 theme,
             ))
         } else {
@@ -4176,7 +4164,7 @@ impl TilingLayout {
                     &self.backdrop_id,
                     is_mouse_tiling,
                     swap_desc.clone(),
-                    overview.1.as_ref().and_then(|(_, tree)| tree.clone()),
+                    overview.1.as_ref().and_then(|(_, tree)| *tree),
                     theme,
                 ))
             } else {
@@ -4211,7 +4199,7 @@ impl TilingLayout {
                 &self.backdrop_id,
                 is_mouse_tiling,
                 swap_desc.clone(),
-                overview.1.as_ref().and_then(|(_, tree)| tree.clone()),
+                overview.1.as_ref().and_then(|(_, tree)| *tree),
                 theme,
             ))
         } else {
@@ -4326,14 +4314,10 @@ where
             seat.get_keyboard()
                 .unwrap()
                 .current_focus()
-                .and_then(|target| TilingLayout::currently_focused_node(&tree, target))
+                .and_then(|target| TilingLayout::currently_focused_node(tree, target))
         })
         .map(|(id, _)| id);
-    let focused_geo = if let Some(focused_id) = focused.as_ref() {
-        Some(*tree.get(focused_id).unwrap().data().geometry())
-    } else {
-        None
-    };
+    let focused_geo = focused.as_ref().map(|focused_id| *tree.get(focused_id).unwrap().data().geometry());
 
     let has_potential_groups = if let Some(focused_id) = focused.as_ref() {
         let focused_node = tree.get(focused_id).unwrap();
@@ -4510,7 +4494,7 @@ where
                                 .parent()
                                 .map(|parent_id| {
                                     matches!(
-                                        tree.get(&parent_id).unwrap().data(),
+                                        tree.get(parent_id).unwrap().data(),
                                         Data::Group {
                                             pill_indicator: Some(_),
                                             ..
@@ -4630,7 +4614,7 @@ where
                         };
                     }
 
-                    if matches!(swap_desc, Some(ref desc) if &desc.node == &node_id) {
+                    if matches!(swap_desc, Some(ref desc) if desc.node == node_id) {
                         if let Some(renderer) = renderer.as_mut() {
                             elements.push(
                                 BackdropShader::element(
@@ -4855,7 +4839,7 @@ where
                         geo.size -= (WINDOW_BACKDROP_GAP * 2, WINDOW_BACKDROP_GAP * 2).into();
                     }
 
-                    if matches!(swap_desc, Some(ref desc) if &desc.node == &node_id && desc.stack_window.is_none())
+                    if matches!(swap_desc, Some(ref desc) if desc.node == node_id && desc.stack_window.is_none())
                     {
                         let swap_geo = swap_geometry(
                             geo.size.as_logical(),
@@ -5092,8 +5076,8 @@ fn render_old_tree(
                 }
 
                 let (scale, offset) = scaled_geo
-                    .map(|adapted_geo| scale_to_center(&original_geo, &adapted_geo))
-                    .unwrap_or_else(|| (1.0.into(), (0, 0).into()));
+                    .map(|adapted_geo| scale_to_center(original_geo, &adapted_geo))
+                    .unwrap_or_else(|| (1.0, (0, 0).into()));
                 let geo = scaled_geo
                     .map(|adapted_geo| {
                         Rectangle::new(
@@ -5206,7 +5190,7 @@ where
             seat.get_keyboard()
                 .unwrap()
                 .current_focus()
-                .and_then(|target| TilingLayout::currently_focused_node(&target_tree, target))
+                .and_then(|target| TilingLayout::currently_focused_node(target_tree, target))
         })
         .map(|(id, _)| id);
     let focused_geo = if let Some(focused) = focused.as_ref() {
@@ -5275,7 +5259,7 @@ where
         let swap_geo = ease(
             Linear,
             EaseRectangle({
-                let mut geo = focused_geo.clone();
+                let mut geo = focused_geo;
                 geo.loc.x += STACK_TAB_HEIGHT;
                 geo.size.h -= STACK_TAB_HEIGHT;
                 geo
@@ -5344,7 +5328,7 @@ where
                 || focused.as_ref() == Some(&node_id)
             {
                 if indicator_thickness > 0 || data.is_group() {
-                    let mut geo = geo.clone();
+                    let mut geo = geo;
 
                     if data.is_group() {
                         let outer_gap: i32 = (if is_overview { GAP_KEYBOARD } else { 4 } as f32
@@ -5437,7 +5421,7 @@ where
                 }
 
                 if let Some((mode, resize)) = resize_indicator.as_mut() {
-                    let mut geo = geo.clone();
+                    let mut geo = geo;
                     geo.loc -= (18, 18).into();
                     geo.size += (36, 36).into();
 
@@ -5572,7 +5556,7 @@ where
                 if swap_desc
                     .as_ref()
                     .map(|swap_desc| {
-                        (&swap_desc.node == &node_id
+                        (swap_desc.node == node_id
                             || target_tree
                                 .ancestor_ids(&node_id)
                                 .unwrap()
@@ -5582,12 +5566,10 @@ where
                     .unwrap_or(false)
                 {
                     swap_elements.extend(elements);
+                } else if animating {
+                    animating_window_elements.extend(elements);
                 } else {
-                    if animating {
-                        animating_window_elements.extend(elements);
-                    } else {
-                        window_elements.extend(elements);
-                    }
+                    window_elements.extend(elements);
                 }
             }
         },
@@ -5666,7 +5648,7 @@ fn render_new_tree(
                 let (scale, offset) = old_scaled_geo
                     .unwrap()
                     .map(|adapted_geo| scale_to_center(original_geo, adapted_geo))
-                    .unwrap_or_else(|| (1.0.into(), (0, 0).into()));
+                    .unwrap_or_else(|| (1.0, (0, 0).into()));
                 (
                     old_scaled_geo
                         .unwrap()
@@ -5694,7 +5676,7 @@ fn render_new_tree(
 
             let (scale, offset) = scaled_geo
                 .map(|adapted_geo| scale_to_center(original_geo, adapted_geo))
-                .unwrap_or_else(|| (1.0.into(), (0, 0).into()));
+                .unwrap_or_else(|| (1.0, (0, 0).into()));
             let new_geo = scaled_geo
                 .map(|adapted_geo| {
                     Rectangle::new(
diff --git a/src/shell/mod.rs b/src/shell/mod.rs
index c34a2e732..00dc808d8 100644
--- a/src/shell/mod.rs
+++ b/src/shell/mod.rs
@@ -170,7 +170,7 @@ impl OverviewMode {
     }
 
     pub fn trigger(&self) -> Option<&Trigger> {
-        self.active_trigger().or_else(|| {
+        self.active_trigger().or({
             if let OverviewMode::Ended(trigger, _) = self {
                 trigger.as_ref()
             } else {
@@ -361,7 +361,7 @@ fn create_workspace(
 ) -> Workspace {
     let workspace_handle = state
         .create_workspace(
-            &group_handle,
+            group_handle,
             if tiling {
                 TilingState::TilingEnabled
             } else {
@@ -394,7 +394,7 @@ fn create_workspace_from_pinned(
 ) -> Workspace {
     let workspace_handle = state
         .create_workspace(
-            &group_handle,
+            group_handle,
             if pinned.tiling_enabled {
                 TilingState::TilingEnabled
             } else {
@@ -533,7 +533,7 @@ impl WorkspaceSet {
         self.sticky_layer.set_output(new_output);
         for window in self.sticky_layer.windows() {
             toplevel_leave_output(&window, &self.output);
-            toplevel_enter_output(&window, &new_output);
+            toplevel_enter_output(&window, new_output);
         }
         for workspace in &mut self.workspaces {
             workspace.set_output(new_output, explicit);
@@ -591,8 +591,7 @@ impl WorkspaceSet {
         // add empty at the end, if necessary
         if self
             .workspaces
-            .last()
-            .map_or(true, |last| !last.is_empty() || last.pinned)
+            .last().is_none_or(|last| !last.is_empty() || last.pinned)
         {
             self.add_empty_workspace(state);
         }
@@ -607,8 +606,7 @@ impl WorkspaceSet {
                 let previous_is_empty = i > 0
                     && self
                         .workspaces
-                        .get(i - 1)
-                        .map_or(false, |w| w.is_empty() && !w.pinned);
+                        .get(i - 1).is_some_and(|w| w.is_empty() && !w.pinned);
                 let keep = if workspace.can_auto_remove(xdg_activation_state) {
                     // Keep empty workspace if it's active, or it's the last workspace,
                     // and the previous worspace is not both active and empty.
@@ -632,7 +630,7 @@ impl WorkspaceSet {
             .filter(|kept| !**kept)
             .count();
 
-        if kept.iter().any(|val| *val == false) {
+        if kept.iter().any(|val| !(*val)) {
             self.update_workspace_idxs(state);
         }
     }
@@ -736,9 +734,9 @@ impl Workspaces {
                 set
             })
             .unwrap_or_else(|| {
-                WorkspaceSet::new(workspace_state, &output, self.autotile, self.theme.clone())
+                WorkspaceSet::new(workspace_state, output, self.autotile, self.theme.clone())
             });
-        workspace_state.add_group_output(&set.group, &output);
+        workspace_state.add_group_output(&set.group, output);
 
         // If this is the first output added, create workspaces for pinned workspaces from config
         for pinned in std::mem::take(&mut self.persisted_workspaces) {
@@ -1152,7 +1150,7 @@ impl Workspaces {
                     s.active = active;
                 });
 
-                if keep.iter().any(|val| *val == false) {
+                if keep.iter().any(|val| !(*val)) {
                     for set in self.sets.values_mut() {
                         set.update_workspace_idxs(workspace_state);
                     }
@@ -1751,7 +1749,7 @@ impl Shell {
             KeyboardFocusTarget::Fullscreen(elem) => self
                 .outputs()
                 .find(|output| {
-                    let workspace = self.active_space(&output).unwrap();
+                    let workspace = self.active_space(output).unwrap();
                     workspace.get_fullscreen() == Some(&elem)
                 })
                 .cloned(),
@@ -1759,7 +1757,7 @@ impl Shell {
                 .outputs()
                 .find(|output| {
                     self.workspaces
-                        .active(&output)
+                        .active(output)
                         .unwrap()
                         .1
                         .tiling_layer
@@ -1809,7 +1807,6 @@ impl Shell {
         match focus_target {
             KeyboardFocusTarget::Group(_group) => {
                 //TODO: decide if we want close actions to apply to groups
-                return;
             }
             KeyboardFocusTarget::Fullscreen(surface) => {
                 surface.close();
@@ -1937,7 +1934,7 @@ impl Shell {
                 .workspaces
                 .spaces()
                 .find(move |workspace| workspace.output() == output)
-                .map(|w| (w.handle.clone(), output.clone())),
+                .map(|w| (w.handle, output.clone())),
             None => self
                 .workspaces
                 .spaces()
@@ -1951,7 +1948,7 @@ impl Shell {
                                 .is_some_and(|m| m.has_surface(surface, WindowSurfaceType::ALL))
                         })
                 })
-                .map(|w| (w.handle.clone(), w.output().clone())),
+                .map(|w| (w.handle, w.output().clone())),
         }
     }
 
@@ -2130,24 +2127,22 @@ impl Shell {
                 }
                 self.overview_mode = OverviewMode::Started(trigger, Instant::now());
             }
-        } else {
-            if matches!(
-                self.overview_mode,
-                OverviewMode::Started(_, _) | OverviewMode::Active(_)
-            ) {
-                let (reverse_duration, trigger) =
-                    if let OverviewMode::Started(trigger, start) = self.overview_mode.clone() {
-                        (
-                            ANIMATION_DURATION
-                                - Instant::now().duration_since(start).min(ANIMATION_DURATION),
-                            Some(trigger),
-                        )
-                    } else {
-                        (Duration::ZERO, self.overview_mode.active_trigger().cloned())
-                    };
-                self.overview_mode =
-                    OverviewMode::Ended(trigger, Instant::now() - reverse_duration);
-            }
+        } else if matches!(
+            self.overview_mode,
+            OverviewMode::Started(_, _) | OverviewMode::Active(_)
+        ) {
+            let (reverse_duration, trigger) =
+                if let OverviewMode::Started(trigger, start) = self.overview_mode.clone() {
+                    (
+                        ANIMATION_DURATION
+                            - Instant::now().duration_since(start).min(ANIMATION_DURATION),
+                        Some(trigger),
+                    )
+                } else {
+                    (Duration::ZERO, self.overview_mode.active_trigger().cloned())
+                };
+            self.overview_mode =
+                OverviewMode::Ended(trigger, Instant::now() - reverse_duration);
         }
     }
 
@@ -2188,12 +2183,10 @@ impl Shell {
                 evlh,
                 self.theme.clone(),
             ));
-        } else {
-            if let Some(direction) = self.resize_mode.active_direction() {
-                self.resize_mode = ResizeMode::Ended(Instant::now(), direction);
-                if let Some((_, direction, edge, _, _, _)) = self.resize_state.as_ref() {
-                    self.finish_resize(*direction, *edge);
-                }
+        } else if let Some(direction) = self.resize_mode.active_direction() {
+            self.resize_mode = ResizeMode::Ended(Instant::now(), direction);
+            if let Some((_, direction, edge, _, _, _)) = self.resize_state.as_ref() {
+                self.finish_resize(*direction, *edge);
             }
         }
     }
@@ -2449,7 +2442,7 @@ impl Shell {
                 .workspaces
                 .sets
                 .get_mut(&output)
-                .or_else(|| self.workspaces.backup_set.as_mut())
+                .or(self.workspaces.backup_set.as_mut())
                 .unwrap();
             set.sticky_layer.map_internal(
                 window.clone(),
@@ -2464,7 +2457,7 @@ impl Shell {
         let workspace = match &state {
             Some(FullscreenRestoreState::Floating { workspace, .. })
             | Some(FullscreenRestoreState::Tiling { workspace, .. }) => {
-                let workspace = self.workspaces.space_for_handle_mut(&workspace);
+                let workspace = self.workspaces.space_for_handle_mut(workspace);
                 let workspace = match workspace {
                     Some(workspace) => workspace,
                     None => self.workspaces.active_mut(&seat.active_output()).unwrap(),
@@ -2936,12 +2929,12 @@ impl Shell {
                 node, focus_stack, ..
             })) => {
                 let new_pos = if follow {
-                    seat.set_active_output(&to_output);
+                    seat.set_active_output(to_output);
                     self.workspaces
-                        .idx_for_handle(&to_output, &to)
+                        .idx_for_handle(to_output, &to)
                         .and_then(|to_idx| {
                             self.activate(
-                                &to_output,
+                                to_output,
                                 to_idx,
                                 WorkspaceDelta::new_shortcut(),
                                 workspace_state,
@@ -2957,7 +2950,7 @@ impl Shell {
                 if let Some(from_workspace) = from_w.get_mut(0) {
                     if let Some(to_workspace) = other_w.iter_mut().find(|w| w.handle == to) {
                         {
-                            let mut stack = to_workspace.focus_stack.get_mut(&seat);
+                            let mut stack = to_workspace.focus_stack.get_mut(seat);
                             for elem in focus_stack.iter().flat_map(|node_id| {
                                 from_workspace.tiling_layer.element_for_node(node_id)
                             }) {
@@ -2982,7 +2975,7 @@ impl Shell {
                             &mut to_workspace.tiling_layer,
                             &to,
                             seat,
-                            to_workspace.focus_stack.get(&seat).iter(),
+                            to_workspace.focus_stack.get(seat).iter(),
                             NodeDesc {
                                 handle: from,
                                 node,
@@ -3003,7 +2996,7 @@ impl Shell {
                                 .collect::<Vec<_>>()
                                 .into_iter()
                             {
-                                to_workspace.toggle_floating_window(&seat, &mapped);
+                                to_workspace.toggle_floating_window(seat, &mapped);
                             }
                             to_workspace.tiling_enabled = false;
                         }
@@ -3145,7 +3138,7 @@ impl Shell {
                 {
                     to_workspace.unmaximize_request(&mapped);
                 }
-                let focus_stack = seat.map(|seat| to_workspace.focus_stack.get(&seat));
+                let focus_stack = seat.map(|seat| to_workspace.focus_stack.get(seat));
                 to_workspace.tiling_layer.map(
                     mapped.clone(),
                     focus_stack.as_ref().map(|x| x.iter()),
@@ -3239,7 +3232,7 @@ impl Shell {
             {
                 to_workspace.unmaximize_request(&mapped);
             }
-            let focus_stack = seat.map(|seat| to_workspace.focus_stack.get(&seat));
+            let focus_stack = seat.map(|seat| to_workspace.focus_stack.get(seat));
             to_workspace.tiling_layer.map(
                 mapped.clone(),
                 focus_stack.as_ref().map(|x| x.iter()),
@@ -3301,7 +3294,7 @@ impl Shell {
     ) -> Option<(MenuGrab, Focus)> {
         let serial = serial.into();
         let Some(GrabStartData::Pointer(start_data)) =
-            check_grab_preconditions(&seat, serial, Some(surface))
+            check_grab_preconditions(seat, serial, Some(surface))
         else {
             return None; // TODO: an application can send a menu request for a touch event
         };
@@ -3316,7 +3309,7 @@ impl Shell {
             if target_stack || !is_stacked {
                 Box::new(
                     window_items(
-                        &mapped,
+                        mapped,
                         is_tiled,
                         is_stacked,
                         is_sticky,
@@ -3333,7 +3326,7 @@ impl Shell {
                     .find(|(s, _)| s.wl_surface().as_deref() == Some(surface))
                     .unwrap();
                 Box::new(
-                    tab_items(&mapped, &tab, is_tiled, config)
+                    tab_items(mapped, &tab, is_tiled, config)
                         .collect::<Vec<Item>>()
                         .into_iter(),
                 ) as Box<dyn Iterator<Item = Item>>
@@ -3352,13 +3345,13 @@ impl Shell {
                     .map(|(mapped, relative_loc)| (set, mapped, relative_loc))
             }) {
             let output = set.output.clone();
-            let global_position = (set.sticky_layer.element_geometry(&mapped).unwrap().loc
+            let global_position = (set.sticky_layer.element_geometry(mapped).unwrap().loc
                 + relative_loc.as_local()
                 + location.as_local())
             .to_global(&output);
             (
                 global_position,
-                items_for_element(&mapped, false, true, false, ResizeEdge::all()),
+                items_for_element(mapped, false, true, false, ResizeEdge::all()),
             )
         } else if let Some((workspace, output)) = self.workspace_for_surface(surface) {
             let workspace = self.workspaces.space_for_handle(&workspace).unwrap();
@@ -3396,7 +3389,7 @@ impl Shell {
 
                 (
                     global_position,
-                    items_for_element(&mapped, is_tiled, false, workspace.tiling_enabled, edge),
+                    items_for_element(mapped, is_tiled, false, workspace.tiling_enabled, edge),
                 )
             }
         } else {
@@ -3436,7 +3429,7 @@ impl Shell {
         let mut element_geo = None;
 
         let mut start_data =
-            check_grab_preconditions(&seat, serial, client_initiated.then_some(surface))?;
+            check_grab_preconditions(seat, serial, client_initiated.then_some(surface))?;
 
         let maybe_fullscreen_workspace = self
             .workspaces
@@ -3523,7 +3516,7 @@ impl Shell {
                     None
                 };
 
-                let layer = if mapped == old_mapped {
+                let layer = if if mapped == old_mapped {
                     let was_floating = workspace.floating_layer.unmap(&mapped, None);
                     let was_tiled = workspace
                         .tiling_layer
@@ -3538,14 +3531,12 @@ impl Shell {
                         .tiling_layer
                         .mapped()
                         .any(|(m, _)| m == &old_mapped)
-                }
-                .then_some(ManagedLayer::Tiling)
-                .unwrap_or(ManagedLayer::Floating);
+                } { ManagedLayer::Tiling } else { ManagedLayer::Floating };
 
                 // if this changed the width, the window was tiled in floating mode
                 if let Some(new_size) = new_size {
                     let output = workspace.output();
-                    let ratio = pos.to_local(&output).x / (elem_geo.loc.x + elem_geo.size.w) as f64;
+                    let ratio = pos.to_local(output).x / (elem_geo.loc.x + elem_geo.size.w) as f64;
 
                     initial_window_location = Point::from((
                         pos.x - (new_size.w as f64 * ratio),
@@ -3650,7 +3641,7 @@ impl Shell {
             KeyboardFocusTarget::Fullscreen(surface) => {
                 if let Some(workspace) = surface
                     .wl_surface()
-                    .and_then(|s| self.workspace_for_surface(&*s))
+                    .and_then(|s| self.workspace_for_surface(&s))
                     .and_then(|(handle, _)| self.workspaces.space_for_handle(&handle))
                 {
                     workspace
@@ -3683,9 +3674,9 @@ impl Shell {
                 .unwrap()
                 .to_global(&set.output);
             Some(geometry)
-        } else if let Some(workspace) = self.space_for(&mapped) {
+        } else if let Some(workspace) = self.space_for(mapped) {
             let geometry = workspace
-                .element_geometry(&mapped)
+                .element_geometry(mapped)
                 .unwrap()
                 .to_global(workspace.output());
             Some(geometry)
@@ -3910,7 +3901,7 @@ impl Shell {
             return None;
         }
 
-        let mut start_data = check_grab_preconditions(&seat, None, None)?;
+        let mut start_data = check_grab_preconditions(seat, None, None)?;
 
         let (floating_layer, geometry) = if let Some(set) = self
             .workspaces
@@ -3924,9 +3915,9 @@ impl Shell {
                 .unwrap()
                 .to_global(&set.output);
             (&mut set.sticky_layer, geometry)
-        } else if let Some(workspace) = self.space_for_mut(&mapped) {
+        } else if let Some(workspace) = self.space_for_mut(mapped) {
             let geometry = workspace
-                .element_geometry(&mapped)
+                .element_geometry(mapped)
                 .unwrap()
                 .to_global(workspace.output());
             (&mut workspace.floating_layer, geometry)
@@ -3968,7 +3959,7 @@ impl Shell {
             ReleaseMode::Click,
         ) {
             grab.into()
-        } else if let Some(ws) = self.space_for_mut(&mapped) {
+        } else if let Some(ws) = self.space_for_mut(mapped) {
             let node_id = mapped.tiling_node_id.lock().unwrap().clone()?;
             let (node, left_up_idx, orientation) = ws.tiling_layer.resize_request(node_id, edge)?;
             ResizeForkGrab::new(
@@ -4026,22 +4017,20 @@ impl Shell {
                     was_maximized: false,
                 },
             });
-        } else {
-            if let Some((workspace, window)) = self.workspaces.sets.values_mut().find_map(|set| {
-                set.workspaces.iter_mut().find_map(|workspace| {
-                    let window = workspace
-                        .get_fullscreen()
-                        .cloned()
-                        .into_iter()
-                        .chain(workspace.mapped().map(|m| m.active_window()))
-                        .find(|s| s == surface);
-                    window.map(|s| (workspace, s))
-                })
-            }) {
-                let to = minimize_rectangle(workspace.output(), &window);
-                if let Some(minimized) = workspace.minimize(&surface, to) {
-                    workspace.minimized_windows.push(minimized);
-                }
+        } else if let Some((workspace, window)) = self.workspaces.sets.values_mut().find_map(|set| {
+            set.workspaces.iter_mut().find_map(|workspace| {
+                let window = workspace
+                    .get_fullscreen()
+                    .cloned()
+                    .into_iter()
+                    .chain(workspace.mapped().map(|m| m.active_window()))
+                    .find(|s| s == surface);
+                window.map(|s| (workspace, s))
+            })
+        }) {
+            let to = minimize_rectangle(workspace.output(), &window);
+            if let Some(minimized) = workspace.minimize(surface, to) {
+                workspace.minimized_windows.push(minimized);
             }
         }
     }
@@ -4113,7 +4102,7 @@ impl Shell {
         {
             let geometry = set.sticky_layer.element_geometry(mapped).unwrap();
             (ManagedLayer::Sticky, &mut set.sticky_layer, geometry)
-        } else if let Some(workspace) = self.space_for_mut(&mapped) {
+        } else if let Some(workspace) = self.space_for_mut(mapped) {
             let layer = if workspace.is_tiled(&mapped.active_window()) {
                 ManagedLayer::Tiling
             } else {
@@ -4187,7 +4176,7 @@ impl Shell {
     ) -> Option<(ResizeGrab, Focus)> {
         let serial = serial.into();
         let start_data =
-            check_grab_preconditions(&seat, serial, client_initiated.then_some(surface))?;
+            check_grab_preconditions(seat, serial, client_initiated.then_some(surface))?;
         let mapped = self.element_for_surface(surface).cloned()?;
         if mapped.is_maximized(true) {
             return None;
@@ -4556,9 +4545,9 @@ impl Shell {
                 mapped.active_window()
             };
 
-            toplevel_leave_output(&window, &old_output);
+            toplevel_leave_output(&window, old_output);
             let old_output = old_output.downgrade();
-            let workspace_handle = self.active_space(&output).unwrap().handle.clone();
+            let workspace_handle = self.active_space(&output).unwrap().handle;
             toplevel_enter_output(&window, &output);
             toplevel_enter_workspace(&window, &workspace_handle);
 
@@ -4585,7 +4574,7 @@ impl Shell {
             let from = workspace.element_geometry(&mapped).unwrap();
             let (surface, state) = workspace.unmap_surface(surface).unwrap();
             window = surface;
-            let handle = workspace.handle.clone();
+            let handle = workspace.handle;
 
             toplevel_leave_output(&window, &workspace.output);
             toplevel_leave_workspace(&window, &workspace.handle);
@@ -4619,7 +4608,7 @@ impl Shell {
         };
 
         if let Some((old_fullscreen, restore, _)) = old_fullscreen {
-            self.remap_unfullscreened_window(old_fullscreen, restore, &loop_handle);
+            self.remap_unfullscreened_window(old_fullscreen, restore, loop_handle);
         }
 
         Some(KeyboardFocusTarget::Fullscreen(window))
@@ -4662,7 +4651,7 @@ impl Shell {
         }
 
         let mut container = cosmic::config::COSMIC_TK.write().unwrap();
-        if &*container != &toolkit {
+        if *container != toolkit {
             *container = toolkit;
             drop(container);
             self.refresh(xdg_activation_state, workspace_state);
@@ -4777,7 +4766,7 @@ pub fn check_grab_preconditions(
     let touch = seat.get_touch().unwrap();
 
     let start_data =
-        if serial.map_or(false, |serial| touch.has_grab(serial)) {
+        if serial.is_some_and(|serial| touch.has_grab(serial)) {
             GrabStartData::Touch(touch.grab_start_data().unwrap())
         } else {
             GrabStartData::Pointer(pointer.grab_start_data().unwrap_or_else(|| {
diff --git a/src/shell/seats.rs b/src/shell/seats.rs
index c1f6dbae2..b1a5a28f4 100644
--- a/src/shell/seats.rs
+++ b/src/shell/seats.rs
@@ -37,6 +37,12 @@ pub struct Seats {
     last_active: Option<Seat<State>>,
 }
 
+impl Default for Seats {
+    fn default() -> Self {
+        Self::new()
+    }
+}
+
 impl Seats {
     pub fn new() -> Seats {
         Seats {
@@ -131,7 +137,7 @@ impl Devices {
 
         let mut map = self.capabilities.borrow_mut();
         map.remove(&id)
-            .unwrap_or(Vec::new())
+            .unwrap_or_default()
             .into_iter()
             .filter(|c| map.values().flatten().all(|has| *c != *has))
             .collect()
diff --git a/src/shell/workspace.rs b/src/shell/workspace.rs
index a67fcb24c..5469d052c 100644
--- a/src/shell/workspace.rs
+++ b/src/shell/workspace.rs
@@ -578,7 +578,7 @@ impl Workspace {
     pub fn unmap_element(&mut self, mapped: &CosmicMapped) -> Option<WorkspaceRestoreData> {
         let was_maximized = if mapped.maximized_state.lock().unwrap().is_some() {
             // If surface is maximized then unmaximize it, so it is assigned to only one layer
-            self.unmaximize_request(&mapped)
+            self.unmaximize_request(mapped)
         } else {
             None
         };
@@ -601,7 +601,7 @@ impl Workspace {
             });
         }
 
-        if let Ok(state) = self.tiling_layer.unmap(&mapped, None) {
+        if let Ok(state) = self.tiling_layer.unmap(mapped, None) {
             return Some(WorkspaceRestoreData::Tiling(Some(TilingRestoreData {
                 state,
                 was_maximized: was_maximized.is_some(),
@@ -610,7 +610,7 @@ impl Workspace {
 
         // unmaximize_request might have triggered a `floating_layer.refresh()`,
         // which may have already removed a non-alive surface.
-        if let Some(floating_geometry) = self.floating_layer.unmap(&mapped, None).or(was_maximized)
+        if let Some(floating_geometry) = self.floating_layer.unmap(mapped, None).or(was_maximized)
         {
             return Some(WorkspaceRestoreData::Floating(Some(FloatingRestoreData {
                 geometry: floating_geometry,
@@ -667,10 +667,8 @@ impl Workspace {
         if let Some(stack) = maybe_stack {
             if stack.len() > 1 {
                 let idx = stack.surfaces().position(|s| &s == surface);
-                let layer = self
-                    .is_tiled(surface)
-                    .then_some(ManagedLayer::Tiling)
-                    .unwrap_or(ManagedLayer::Floating);
+                let layer = if self
+                    .is_tiled(surface) { ManagedLayer::Tiling } else { ManagedLayer::Floating };
                 return idx
                     .and_then(|idx| stack.remove_idx(idx))
                     .map(|s| (s, layer.into()));
@@ -856,14 +854,14 @@ impl Workspace {
         self.fullscreen
             .as_ref()
             .filter(|f| last_focused.is_some_and(|t| t == &f.surface))
-            .and_then(|f| check_fullscreen(f))
+            .and_then(check_fullscreen)
             .or_else(|| self.floating_layer.popup_surface_under(location))
             .or_else(|| self.tiling_layer.popup_surface_under(location, overview))
             .or_else(|| {
                 self.fullscreen
                     .as_ref()
                     .filter(|f| last_focused.is_none_or(|t| t != &f.surface))
-                    .and_then(|f| check_fullscreen(f))
+                    .and_then(check_fullscreen)
             })
             .map(|(m, p)| (m, p.to_global(&self.output)))
     }
@@ -909,14 +907,14 @@ impl Workspace {
         self.fullscreen
             .as_ref()
             .filter(|f| last_focused.is_some_and(|t| t == &f.surface))
-            .and_then(|f| check_fullscreen(f))
+            .and_then(check_fullscreen)
             .or_else(|| self.floating_layer.toplevel_surface_under(location))
             .or_else(|| self.tiling_layer.toplevel_surface_under(location, overview))
             .or_else(|| {
                 self.fullscreen
                     .as_ref()
                     .filter(|f| last_focused.is_none_or(|t| t != &f.surface))
-                    .and_then(|f| check_fullscreen(f))
+                    .and_then(check_fullscreen)
             })
             .map(|(m, p)| (m, p.to_global(&self.output)))
     }
@@ -952,8 +950,8 @@ impl Workspace {
                 match state.original_layer {
                     ManagedLayer::Tiling if self.tiling_enabled => {
                         // should still be mapped in tiling
-                        let geo = self.tiling_layer.element_geometry(&elem);
-                        self.floating_layer.unmap(&elem, geo);
+                        let geo = self.tiling_layer.element_geometry(elem);
+                        self.floating_layer.unmap(elem, geo);
                         elem.output_enter(&self.output, elem.bbox());
                         elem.set_maximized(false);
                         elem.set_geometry(state.original_geometry.to_global(&self.output));
@@ -1252,7 +1250,7 @@ impl Workspace {
             Some((
                 surface.surface.clone(),
                 surface.previous_state.clone(),
-                surface.previous_geometry.clone(),
+                surface.previous_geometry,
             ))
         } else {
             None
@@ -1360,7 +1358,7 @@ impl Workspace {
                 self.floating_layer.map(window.clone(), None);
             } else if self.floating_layer.mapped().any(|w| w == window) {
                 let focus_stack = self.focus_stack.get(seat);
-                self.floating_layer.unmap(&window, None);
+                self.floating_layer.unmap(window, None);
                 self.tiling_layer
                     .map(window.clone(), Some(focus_stack.iter()), None)
             }
@@ -1446,7 +1444,7 @@ impl Workspace {
                             .unwrap()
                             .clone()
                             .map(|node_id| NodeDesc {
-                                handle: self.handle.clone(),
+                                handle: self.handle,
                                 node: node_id.clone(),
                                 stack_window: if mapped
                                     .stack_ref()
@@ -1467,7 +1465,7 @@ impl Workspace {
             KeyboardFocusTarget::Group(WindowGroup {
                 node, focus_stack, ..
             }) => Some(NodeDesc {
-                handle: self.handle.clone(),
+                handle: self.handle,
                 node,
                 stack_window: None,
                 focus_stack,
@@ -1571,7 +1569,7 @@ impl Workspace {
         };
 
         if matches!(focused, Some(FocusTarget::Fullscreen(_))) {
-            elements.extend(fullscreen_elements.drain(..));
+            elements.append(&mut fullscreen_elements);
         }
 
         if !matches!(focused, Some(FocusTarget::Fullscreen(_)))
diff --git a/src/shell/zoom.rs b/src/shell/zoom.rs
index 619c9cf72..62dc3fabd 100644
--- a/src/shell/zoom.rs
+++ b/src/shell/zoom.rs
@@ -80,7 +80,7 @@ impl OutputZoomState {
         let focal_point = if output_geometry.contains(cursor_position) {
             match movement {
                 ZoomMovement::Continuously | ZoomMovement::OnEdge => {
-                    cursor_position.to_local(&output)
+                    cursor_position.to_local(output)
                 }
                 ZoomMovement::Centered => {
                     let mut zoomed_output_geometry = output.geometry().to_f64().downscale(level);
@@ -89,18 +89,18 @@ impl OutputZoomState {
 
                     let mut focal_point = zoomed_output_geometry
                         .loc
-                        .to_local(&output)
+                        .to_local(output)
                         .upscale(level)
-                        .to_global(&output);
+                        .to_global(output);
                     focal_point.x = focal_point.x.clamp(
-                        output_geometry.loc.x as f64,
-                        ((output_geometry.loc.x + output_geometry.size.w) as f64).next_lower(), // FIXME: Replace with f64::next_down when stable
+                        output_geometry.loc.x,
+                        (output_geometry.loc.x + output_geometry.size.w).next_lower(), // FIXME: Replace with f64::next_down when stable
                     );
                     focal_point.y = focal_point.y.clamp(
-                        output_geometry.loc.y as f64,
-                        ((output_geometry.loc.y + output_geometry.size.h) as f64).next_lower(), // FIXME: Replace with f64::next_down when stable
+                        output_geometry.loc.y,
+                        (output_geometry.loc.y + output_geometry.size.h).next_lower(), // FIXME: Replace with f64::next_down when stable
                     );
-                    focal_point.to_local(&output)
+                    focal_point.to_local(output)
                 }
             }
         } else {
@@ -282,16 +282,16 @@ impl ZoomState {
                 if !zoomed_output_geometry
                     .overlaps_or_touches(Rectangle::new(original_position, Size::from((16, 16))))
                 {
-                    zoomed_output_geometry.loc = cursor_position.to_global(&output)
+                    zoomed_output_geometry.loc = cursor_position.to_global(output)
                         - zoomed_output_geometry.size.downscale(2).to_point();
                     let mut focal_point = zoomed_output_geometry
                         .loc
-                        .to_local(&output)
+                        .to_local(output)
                         .upscale(
                             output_geometry.size.w
                                 / (output_geometry.size.w - zoomed_output_geometry.size.w),
                         )
-                        .to_global(&output);
+                        .to_global(output);
                     focal_point.x = focal_point.x.clamp(
                         output_geometry.loc.x,
                         output_geometry.loc.x + output_geometry.size.w - 1,
@@ -302,10 +302,10 @@ impl ZoomState {
                     );
                     output_state_ref.previous_point =
                         Some((output_state_ref.focal_point, Instant::now()));
-                    output_state_ref.focal_point = focal_point.to_local(&output).to_f64();
-                } else if !zoomed_output_geometry.contains(cursor_position.to_global(&output)) {
-                    let mut diff = output_state_ref.focal_point.to_global(&output)
-                        + (cursor_position.to_global(&output) - original_position)
+                    output_state_ref.focal_point = focal_point.to_local(output).to_f64();
+                } else if !zoomed_output_geometry.contains(cursor_position.to_global(output)) {
+                    let mut diff = output_state_ref.focal_point.to_global(output)
+                        + (cursor_position.to_global(output) - original_position)
                             .to_f64()
                             .upscale(output_state_ref.level);
                     diff.x = diff.x.clamp(
@@ -316,18 +316,18 @@ impl ZoomState {
                         output_geometry.loc.y as f64,
                         ((output_geometry.loc.y + output_geometry.size.h) as f64).next_lower(), // FIXME: Replace with f64::next_down when stable
                     );
-                    diff -= output_state_ref.focal_point.to_global(&output);
+                    diff -= output_state_ref.focal_point.to_global(output);
 
                     output_state_ref.focal_point += diff.as_logical().as_local();
                 }
             }
             ZoomMovement::Centered => {
-                zoomed_output_geometry.loc = cursor_position.to_global(&output)
+                zoomed_output_geometry.loc = cursor_position.to_global(output)
                     - zoomed_output_geometry.size.downscale(2).to_point();
 
                 let mut focal_point = zoomed_output_geometry
                     .loc
-                    .to_local(&output)
+                    .to_local(output)
                     .upscale(
                         output_geometry
                             .size
@@ -335,7 +335,7 @@ impl ZoomState {
                             .checked_div(output_geometry.size.w - zoomed_output_geometry.size.w)
                             .unwrap_or(1),
                     )
-                    .to_global(&output);
+                    .to_global(output);
                 focal_point.x = focal_point.x.clamp(
                     output_geometry.loc.x,
                     output_geometry.loc.x + output_geometry.size.w - 1,
@@ -344,7 +344,7 @@ impl ZoomState {
                     output_geometry.loc.y,
                     output_geometry.loc.y + output_geometry.size.h - 1,
                 );
-                output_state_ref.focal_point = focal_point.to_local(&output).to_f64();
+                output_state_ref.focal_point = focal_point.to_local(output).to_f64();
             }
         }
     }
diff --git a/src/state.rs b/src/state.rs
index fb1dff3cb..3340fbb91 100644
--- a/src/state.rs
+++ b/src/state.rs
@@ -161,7 +161,7 @@ impl ClientData for ClientState {
 pub fn advertised_node_for_client(client: &Client) -> Option<DrmNode> {
     // Lets check the global drm-node the client got either through default-feedback or wl_drm
     if let Some(normal_client) = client.get_data::<ClientState>() {
-        return normal_client.advertised_drm_node.clone();
+        return normal_client.advertised_drm_node;
     }
     // last but not least all xwayland-surfaces should also share a single node
     if let Some(xwayland_client) = client.get_data::<XWaylandClientData>() {
@@ -338,7 +338,7 @@ impl BackendData {
             BackendData::Kms(state) => {
                 return state
                     .dmabuf_imported(client, global, dmabuf)
-                    .map(|node| Some(node));
+                    .map(Some);
             }
             BackendData::Winit(state) => {
                 state.backend.renderer().import_dmabuf(&dmabuf, None)?;
@@ -402,7 +402,7 @@ impl BackendData {
     }
 }
 
-impl<'a> LockedBackend<'a> {
+impl LockedBackend<'_> {
     pub fn all_outputs(&self) -> Vec<Output> {
         match self {
             LockedBackend::Kms(state) => state.all_outputs(),
@@ -515,11 +515,11 @@ impl<'a> LockedBackend<'a> {
             });
 
             match final_config.enabled {
-                OutputState::Enabled => shell_ref.workspaces.add_output(&output, workspace_state),
+                OutputState::Enabled => shell_ref.workspaces.add_output(output, workspace_state),
                 _ => {
                     let shell = &mut *shell_ref;
                     shell.workspaces.remove_output(
-                        &output,
+                        output,
                         shell.seats.iter(),
                         workspace_state,
                         xdg_activation_state,
@@ -527,7 +527,7 @@ impl<'a> LockedBackend<'a> {
                 }
             }
 
-            layer_map_for_output(&output).arrange();
+            layer_map_for_output(output).arrange();
         }
 
         // Update layout for changes in resolution, scale, orientation
@@ -574,14 +574,12 @@ impl From<DrmNode> for KmsNodes {
 
 pub fn client_has_no_security_context(client: &Client) -> bool {
     client
-        .get_data::<ClientState>()
-        .map_or(true, |client_state| client_state.security_context.is_none())
+        .get_data::<ClientState>().is_none_or(|client_state| client_state.security_context.is_none())
 }
 
 pub fn client_is_privileged(client: &Client) -> bool {
     client
-        .get_data::<ClientState>()
-        .map_or(false, |client_state| client_state.privileged)
+        .get_data::<ClientState>().is_some_and(|client_state| client_state.privileged)
 }
 
 fn enable_wayland_security() -> bool {
@@ -626,24 +624,24 @@ impl State {
         let seat_state = SeatState::<Self>::new();
         let viewporter_state = ViewporterState::new::<Self>(dh);
         let wl_drm_state = WlDrmState::<Option<DrmNode>>::default();
-        let kde_decoration_state = KdeDecorationState::new::<Self>(&dh, Mode::Client);
-        let xdg_decoration_state = XdgDecorationState::new::<Self>(&dh);
+        let kde_decoration_state = KdeDecorationState::new::<Self>(dh, Mode::Client);
+        let xdg_decoration_state = XdgDecorationState::new::<Self>(dh);
         let session_lock_manager_state =
-            SessionLockManagerState::new::<Self, _>(&dh, client_is_privileged);
-        XWaylandKeyboardGrabState::new::<Self>(&dh);
-        let xwayland_shell_state = XWaylandShellState::new::<Self>(&dh);
-        PointerConstraintsState::new::<Self>(&dh);
-        PointerGesturesState::new::<Self>(&dh);
-        TabletManagerState::new::<Self>(&dh);
-        SecurityContextState::new::<Self, _>(&dh, client_has_no_security_context);
-        InputMethodManagerState::new::<Self, _>(&dh, client_is_privileged);
-        TextInputManagerState::new::<Self>(&dh);
-        VirtualKeyboardManagerState::new::<State, _>(&dh, client_is_privileged);
-        AlphaModifierState::new::<Self>(&dh);
-        SinglePixelBufferState::new::<Self>(&dh);
-
-        let idle_notifier_state = IdleNotifierState::<Self>::new(&dh, handle.clone());
-        let idle_inhibit_manager_state = IdleInhibitManagerState::new::<State>(&dh);
+            SessionLockManagerState::new::<Self, _>(dh, client_is_privileged);
+        XWaylandKeyboardGrabState::new::<Self>(dh);
+        let xwayland_shell_state = XWaylandShellState::new::<Self>(dh);
+        PointerConstraintsState::new::<Self>(dh);
+        PointerGesturesState::new::<Self>(dh);
+        TabletManagerState::new::<Self>(dh);
+        SecurityContextState::new::<Self, _>(dh, client_has_no_security_context);
+        InputMethodManagerState::new::<Self, _>(dh, client_is_privileged);
+        TextInputManagerState::new::<Self>(dh);
+        VirtualKeyboardManagerState::new::<State, _>(dh, client_is_privileged);
+        AlphaModifierState::new::<Self>(dh);
+        SinglePixelBufferState::new::<Self>(dh);
+
+        let idle_notifier_state = IdleNotifierState::<Self>::new(dh, handle.clone());
+        let idle_inhibit_manager_state = IdleInhibitManagerState::new::<State>(dh);
         let idle_inhibiting_surfaces = HashSet::new();
 
         let data_control_state = crate::utils::env::bool_var("COSMIC_DATA_CONTROL_ENABLED")
@@ -839,30 +837,28 @@ impl State {
                         }
                     }
                 }
-            } else {
-                if let Some(_fd) = self.common.inhibit_lid_fd.take() {
-                    debug!("Removing inhibitor-lock on lid switch");
-
-                    let backend = self.backend.lock();
-                    let output = backend
-                        .all_outputs()
-                        .iter()
-                        .find(|o| o.is_internal())
-                        .cloned();
-                    backend.enable_internal_output(&mut self.common.output_configuration_state);
-                    std::mem::drop(backend);
-
-                    if let Err(err) = self.refresh_output_config() {
-                        warn!(?err, "Failed to re-enable internal connector");
-                        if let Some(output) = output {
-                            output.config_mut().enabled = OutputState::Disabled;
-                            if let Err(err) = self.refresh_output_config() {
-                                error!("Unrecoverable output configuration error: {}", err);
-                            }
+            } else if let Some(_fd) = self.common.inhibit_lid_fd.take() {
+                debug!("Removing inhibitor-lock on lid switch");
+
+                let backend = self.backend.lock();
+                let output = backend
+                    .all_outputs()
+                    .iter()
+                    .find(|o| o.is_internal())
+                    .cloned();
+                backend.enable_internal_output(&mut self.common.output_configuration_state);
+                std::mem::drop(backend);
+
+                if let Err(err) = self.refresh_output_config() {
+                    warn!(?err, "Failed to re-enable internal connector");
+                    if let Some(output) = output {
+                        output.config_mut().enabled = OutputState::Disabled;
+                        if let Err(err) = self.refresh_output_config() {
+                            error!("Unrecoverable output configuration error: {}", err);
                         }
                     }
-                    // drop _fd
                 }
+                // drop _fd
             }
         }
     }
@@ -992,10 +988,10 @@ impl Common {
             if let Some(lock_surface) = session_lock.surfaces.get(output) {
                 if let Some(feedback) =
                     advertised_node_for_surface(lock_surface.wl_surface(), &self.display_handle)
-                        .and_then(|source| dmabuf_feedback(source))
+                        .and_then(&mut dmabuf_feedback)
                 {
                     send_dmabuf_feedback_surface_tree(
-                        &lock_surface.wl_surface(),
+                        lock_surface.wl_surface(),
                         output,
                         surface_primary_scanout_output,
                         |surface, _| {
@@ -1021,7 +1017,7 @@ impl Common {
             if let CursorImageStatus::Surface(wl_surface) = cursor_status {
                 if let Some(feedback) =
                     advertised_node_for_surface(&wl_surface, &self.display_handle)
-                        .and_then(|source| dmabuf_feedback(source))
+                        .and_then(&mut dmabuf_feedback)
                 {
                     send_dmabuf_feedback_surface_tree(
                         &wl_surface,
@@ -1042,7 +1038,7 @@ impl Common {
             if let Some(icon) = get_dnd_icon(seat) {
                 if let Some(feedback) =
                     advertised_node_for_surface(&icon.surface, &self.display_handle)
-                        .and_then(|source| dmabuf_feedback(source))
+                        .and_then(&mut dmabuf_feedback)
                 {
                     send_dmabuf_feedback_surface_tree(
                         &icon.surface,
@@ -1068,7 +1064,7 @@ impl Common {
                             .and_then(|wl_surface| {
                                 advertised_node_for_surface(&wl_surface, &self.display_handle)
                             })
-                            .and_then(|source| dmabuf_feedback(source))
+                            .and_then(&mut dmabuf_feedback)
                         {
                             window.send_dmabuf_feedback(
                                 output,
@@ -1096,7 +1092,7 @@ impl Common {
                         .and_then(|wl_surface| {
                             advertised_node_for_surface(&wl_surface, &self.display_handle)
                         })
-                        .and_then(|source| dmabuf_feedback(source))
+                        .and_then(&mut dmabuf_feedback)
                     {
                         window.send_dmabuf_feedback(
                             output,
@@ -1115,7 +1111,7 @@ impl Common {
                     .and_then(|wl_surface| {
                         advertised_node_for_surface(&wl_surface, &self.display_handle)
                     })
-                    .and_then(|source| dmabuf_feedback(source))
+                    .and_then(&mut dmabuf_feedback)
                 {
                     window.send_dmabuf_feedback(
                         output,
@@ -1132,7 +1128,7 @@ impl Common {
                         .and_then(|wl_surface| {
                             advertised_node_for_surface(&wl_surface, &self.display_handle)
                         })
-                        .and_then(|source| dmabuf_feedback(source))
+                        .and_then(&mut dmabuf_feedback)
                     {
                         window.send_dmabuf_feedback(
                             output,
@@ -1149,7 +1145,7 @@ impl Common {
             if let Some(wl_surface) = or.wl_surface() {
                 if let Some(feedback) =
                     advertised_node_for_surface(&wl_surface, &self.display_handle)
-                        .and_then(|source| dmabuf_feedback(source))
+                        .and_then(&mut dmabuf_feedback)
                 {
                     send_dmabuf_feedback_surface_tree(
                         &wl_surface,
@@ -1172,7 +1168,7 @@ impl Common {
         for layer_surface in map.layers() {
             if let Some(feedback) =
                 advertised_node_for_surface(layer_surface.wl_surface(), &self.display_handle)
-                    .and_then(|source| dmabuf_feedback(source))
+                    .and_then(&mut dmabuf_feedback)
             {
                 layer_surface.send_dmabuf_feedback(
                     output,
diff --git a/src/systemd.rs b/src/systemd.rs
index 1ec18f480..100a5467a 100644
--- a/src/systemd.rs
+++ b/src/systemd.rs
@@ -12,11 +12,11 @@ pub fn ready(common: &Common) {
             .env("WAYLAND_DISPLAY", &common.socket)
             .env(
                 "DISPLAY",
-                &common
+                common
                     .xwayland_state
                     .as_ref()
                     .map(|s| format!(":{}", s.display))
-                    .unwrap_or(String::new()),
+                    .unwrap_or_default(),
             )
             .status()
         {
diff --git a/src/utils/env.rs b/src/utils/env.rs
index 22188b982..87afc1286 100644
--- a/src/utils/env.rs
+++ b/src/utils/env.rs
@@ -106,8 +106,7 @@ fn try_parse_dev_from_str(val: &str) -> Option<DeviceIdentifier> {
 
         let node = node
             .node_with_type(NodeType::Render)
-            .map(|res| res.ok())
-            .flatten()
+            .and_then(|res| res.ok())
             .unwrap_or(node);
         Some(DeviceIdentifier::Node(node))
     } else if val.contains(':') {
@@ -140,8 +139,7 @@ fn try_parse_dev_from_str(val: &str) -> Option<DeviceIdentifier> {
 
         let node = node
             .node_with_type(NodeType::Render)
-            .map(|res| res.ok())
-            .flatten()
+            .and_then(|res| res.ok())
             .unwrap_or(node);
         Some(DeviceIdentifier::Node(node))
     } else {
@@ -159,8 +157,7 @@ fn try_parse_dev_from_str(val: &str) -> Option<DeviceIdentifier> {
 
         let node = node
             .node_with_type(NodeType::Render)
-            .map(|res| res.ok())
-            .flatten()
+            .and_then(|res| res.ok())
             .unwrap_or(node);
         Some(DeviceIdentifier::Node(node))
     }
diff --git a/src/utils/iced.rs b/src/utils/iced.rs
index 04c6b8268..e66591ff4 100644
--- a/src/utils/iced.rs
+++ b/src/utils/iced.rs
@@ -206,10 +206,10 @@ impl<P: Program + Send + Clone + 'static> Clone for IcedElementInternal<P> {
             additional_scale: self.additional_scale,
             outputs: self.outputs.clone(),
             buffers: self.buffers.clone(),
-            pending_realloc: self.pending_realloc.clone(),
-            size: self.size.clone(),
+            pending_realloc: self.pending_realloc,
+            size: self.size,
             last_seat: self.last_seat.clone(),
-            cursor_pos: self.cursor_pos.clone(),
+            cursor_pos: self.cursor_pos,
             touch_map: self.touch_map.clone(),
             theme: self.theme.clone(),
             renderer,
@@ -632,7 +632,7 @@ impl<P: Program + Send + 'static> TouchTarget<crate::state::State> for IcedEleme
         internal.touch_map.insert(id, position);
         internal.cursor_pos = Some(event_location);
         *internal.last_seat.lock().unwrap() = Some((seat.clone(), seq));
-        let _ = internal.update(false);
+        internal.update(false);
     }
 
     fn up(
@@ -649,7 +649,7 @@ impl<P: Program + Send + 'static> TouchTarget<crate::state::State> for IcedEleme
             internal
                 .state
                 .queue_event(Event::Touch(TouchEvent::FingerLifted { id, position }));
-            let _ = internal.update(false);
+            internal.update(false);
         }
     }
 
@@ -670,7 +670,7 @@ impl<P: Program + Send + 'static> TouchTarget<crate::state::State> for IcedEleme
             .queue_event(Event::Touch(TouchEvent::FingerMoved { id, position }));
         internal.touch_map.insert(id, position);
         internal.cursor_pos = Some(event_location);
-        let _ = internal.update(false);
+        internal.update(false);
     }
 
     fn frame(
@@ -693,7 +693,7 @@ impl<P: Program + Send + 'static> TouchTarget<crate::state::State> for IcedEleme
                 .state
                 .queue_event(Event::Touch(TouchEvent::FingerLost { id, position }));
         }
-        let _ = internal.update(false);
+        internal.update(false);
     }
 
     fn shape(
@@ -771,7 +771,7 @@ impl<P: Program + Send + 'static> KeyboardTarget<crate::state::State> for IcedEl
         internal
             .state
             .queue_event(Event::Keyboard(KeyboardEvent::ModifiersChanged(mods)));
-        let _ = internal.update(false);
+        internal.update(false);
     }
 }
 
@@ -804,7 +804,7 @@ impl<P: Program + Send + 'static> SpaceElement for IcedElement<P> {
         } else {
             WindowEvent::Unfocused
         }));
-        let _ = internal.update(false);
+        internal.update(false);
     }
 
     fn output_enter(&self, output: &Output, _overlap: Rectangle<i32, Logical>) {
@@ -940,7 +940,7 @@ where
                         .and_then(|(last_primitives, last_color)| {
                             (last_color == &background_color).then(|| {
                                 damage::diff(
-                                    &last_primitives,
+                                    last_primitives,
                                     current_layers,
                                     |_| {
                                         vec![cosmic::iced::Rectangle::new(
@@ -1012,7 +1012,7 @@ where
             match MemoryRenderBufferRenderElement::from_buffer(
                 renderer,
                 location.to_f64(),
-                &buffer,
+                buffer,
                 Some(alpha),
                 Some(Rectangle::from_size(
                     size.to_f64()
diff --git a/src/utils/prelude.rs b/src/utils/prelude.rs
index fdd88adea..630023036 100644
--- a/src/utils/prelude.rs
+++ b/src/utils/prelude.rs
@@ -2,7 +2,7 @@ use cosmic_comp_config::output::comp::{AdaptiveSync, OutputConfig, OutputState};
 use smithay::{
     backend::drm::VrrSupport as Support,
     output::{Output, WeakOutput},
-    utils::{Rectangle, Transform},
+    utils::Rectangle,
 };
 
 pub use super::geometry::*;
@@ -50,7 +50,7 @@ impl OutputExt for Output {
 
     fn geometry(&self) -> Rectangle<i32, Global> {
         Rectangle::new(self.current_location(), {
-            Transform::from(self.current_transform())
+            self.current_transform()
                 .transform_size(
                     self.current_mode()
                         .map(|m| m.size)
@@ -104,13 +104,12 @@ impl OutputExt for Output {
     fn adaptive_sync_support(&self) -> Option<Support> {
         self.user_data()
             .get::<VrrSupport>()
-            .map(|vrr| match vrr.0.load(Ordering::SeqCst) {
+            .and_then(|vrr| match vrr.0.load(Ordering::SeqCst) {
                 0 => None,
                 2 => Some(Support::RequiresModeset),
                 3 => Some(Support::Supported),
                 _ => Some(Support::NotSupported),
             })
-            .flatten()
     }
 
     fn set_adaptive_sync_support(&self, vrr: Option<Support>) {
diff --git a/src/utils/screenshot.rs b/src/utils/screenshot.rs
index 95c46321e..5ec34187f 100644
--- a/src/utils/screenshot.rs
+++ b/src/utils/screenshot.rs
@@ -79,7 +79,7 @@ pub fn screenshot_window(state: &mut State, surface: &CosmicSurface) {
             ));
             let file = std::fs::File::create(path.join(name))?;
 
-            let ref mut writer = std::io::BufWriter::new(file);
+            let writer = &mut std::io::BufWriter::new(file);
             let mut encoder = png::Encoder::new(writer, bbox.size.w as u32, bbox.size.h as u32);
             encoder.set_color(png::ColorType::Rgba);
             encoder.set_depth(png::BitDepth::Eight);
@@ -93,7 +93,7 @@ pub fn screenshot_window(state: &mut State, surface: &CosmicSurface) {
             );
             encoder.set_source_chromaticities(source_chromaticities);
             let mut writer = encoder.write_header()?;
-            writer.write_image_data(&gl_data)?;
+            writer.write_image_data(gl_data)?;
         }
 
         Ok(())
diff --git a/src/wayland/handlers/atspi.rs b/src/wayland/handlers/atspi.rs
index 277e0ef42..eb4adc7cf 100644
--- a/src/wayland/handlers/atspi.rs
+++ b/src/wayland/handlers/atspi.rs
@@ -14,7 +14,7 @@ use smithay::{
 };
 use std::{
     collections::{HashMap, HashSet},
-    ffi::{CStr, CString},
+    ffi::CString,
     mem,
     os::unix::{io::AsFd, net::UnixStream},
 };
@@ -49,7 +49,7 @@ impl AtspiClient {
         modifiers: &ModifiersState,
     ) {
         let keymap_text = keymap.get_as_string(xkb::KEYMAP_FORMAT_TEXT_V1);
-        let name = CStr::from_bytes_with_nul(b"eis-keymap\0").unwrap();
+        let name = c"eis-keymap";
         let file = SealedFile::with_content(name, &CString::new(keymap_text).unwrap()).unwrap();
 
         let device = seat.add_device(
@@ -260,7 +260,7 @@ fn handle_event(
         }
         Ok(EisRequestSourceEvent::Request(EisRequest::Bind(request))) => {
             if connection.has_interface("ei_keyboard")
-                && request.capabilities & 2 << DeviceCapability::Keyboard as u64 != 0
+                && request.capabilities & (2 << DeviceCapability::Keyboard as u64) != 0
             {
                 let keymap = keymap_or_default(state.common.config.xkb_config());
                 client.add_keyboard(
diff --git a/src/wayland/handlers/buffer.rs b/src/wayland/handlers/buffer.rs
index 83240822e..2bb6b4cc8 100644
--- a/src/wayland/handlers/buffer.rs
+++ b/src/wayland/handlers/buffer.rs
@@ -11,16 +11,13 @@ impl BufferHandler for State {
     fn buffer_destroyed(&mut self, buffer: &WlBuffer) {
         if let BackendData::Kms(kms_state) = &mut self.backend {
             for device in kms_state.drm_devices.values_mut() {
-                if device.inner.active_buffers.remove(&buffer.downgrade()) {
-                    if !device
+                if device.inner.active_buffers.remove(&buffer.downgrade()) && !device
                         .inner
-                        .in_use(kms_state.primary_node.read().unwrap().as_ref())
-                    {
-                        if let Err(err) = kms_state.refresh_used_devices() {
-                            warn!(?err, "Failed to init devices.");
-                        };
-                        break;
-                    }
+                        .in_use(kms_state.primary_node.read().unwrap().as_ref()) {
+                    if let Err(err) = kms_state.refresh_used_devices() {
+                        warn!(?err, "Failed to init devices.");
+                    };
+                    break;
                 }
             }
         }
diff --git a/src/wayland/handlers/compositor.rs b/src/wayland/handlers/compositor.rs
index 1e33f59a5..ce0bc557d 100644
--- a/src/wayland/handlers/compositor.rs
+++ b/src/wayland/handlers/compositor.rs
@@ -122,7 +122,7 @@ pub fn frame_time_estimation(clock: &Clock<Monotonic>, states: &SurfaceData) ->
     if let Some(ref last) = data.last_commit {
         // if the time since the last commit is already higher than our estimation,
         // there is no reason to not use that as a better "guess"
-        let diff = Time::elapsed(&last, clock.now());
+        let diff = Time::elapsed(last, clock.now());
         Some(diff.max(data.estimation))
     } else {
         Some(data.estimation)
@@ -275,7 +275,7 @@ impl CompositorHandler for State {
 
         // schedule a new render
         if let Some(output) = shell.visible_output_for_surface(surface) {
-            self.backend.schedule_render(&output);
+            self.backend.schedule_render(output);
         }
 
         if mapped {
@@ -349,7 +349,7 @@ impl CompositorHandler for State {
             if let Some(element) = shell.element_for_surface(surface).cloned() {
                 crate::shell::layout::floating::ResizeSurfaceGrab::apply_resize_to_location(
                     element.clone(),
-                    &mut *shell,
+                    &mut shell,
                 );
             }
         }
@@ -392,8 +392,8 @@ impl State {
                 } else {
                     None
                 };
-                if toplevel_ensure_initial_configure(&toplevel, initial_size)
-                    && with_renderer_surface_state(&surface, |state| state.buffer().is_some())
+                if toplevel_ensure_initial_configure(toplevel, initial_size)
+                    && with_renderer_surface_state(surface, |state| state.buffer().is_some())
                         .unwrap_or(false)
                 {
                     let window = pending.surface.clone();
diff --git a/src/wayland/handlers/data_device.rs b/src/wayland/handlers/data_device.rs
index a15321baa..11c7cac7e 100644
--- a/src/wayland/handlers/data_device.rs
+++ b/src/wayland/handlers/data_device.rs
@@ -68,7 +68,7 @@ impl ClientDndGrabHandler for State {
         seat: Seat<Self>,
     ) {
         let user_data = seat.user_data();
-        user_data.insert_if_missing_threadsafe::<Mutex<Option<DnDIcon>>, _>(|| Default::default());
+        user_data.insert_if_missing_threadsafe::<Mutex<Option<DnDIcon>>, _>(Default::default);
 
         let offset = if let CursorImageStatus::Surface(ref surface) = seat.cursor_image_status() {
             compositor::with_states(surface, |states| {
diff --git a/src/wayland/handlers/decoration.rs b/src/wayland/handlers/decoration.rs
index 7bdbc5ba1..5e1d0c5aa 100644
--- a/src/wayland/handlers/decoration.rs
+++ b/src/wayland/handlers/decoration.rs
@@ -36,12 +36,11 @@ impl PreferredDecorationMode {
     pub fn mode(window: &Window) -> Option<XdgMode> {
         let user_data = window.user_data();
         user_data.insert_if_missing(|| PreferredDecorationMode(RefCell::new(None)));
-        user_data
+        *user_data
             .get::<PreferredDecorationMode>()
             .unwrap()
             .0
             .borrow()
-            .clone()
     }
 
     pub fn update(window: &Window, update: Option<XdgMode>) {
@@ -56,21 +55,12 @@ impl PreferredDecorationMode {
 }
 
 pub type KdeDecorationData = Mutex<KdeDecorationSurfaceState>;
-#[derive(Debug)]
+#[derive(Debug, Default)]
 pub struct KdeDecorationSurfaceState {
     pub mode: Option<KdeMode>,
     pub objs: Vec<OrgKdeKwinServerDecoration>,
 }
 
-impl Default for KdeDecorationSurfaceState {
-    fn default() -> Self {
-        KdeDecorationSurfaceState {
-            mode: None,
-            objs: Vec::new(),
-        }
-    }
-}
-
 impl XdgDecorationHandler for State {
     fn new_decoration(&mut self, toplevel: ToplevelSurface) {
         let shell = self.common.shell.read();
diff --git a/src/wayland/handlers/output_power.rs b/src/wayland/handlers/output_power.rs
index d7d241546..1109ac00a 100644
--- a/src/wayland/handlers/output_power.rs
+++ b/src/wayland/handlers/output_power.rs
@@ -46,7 +46,7 @@ fn kms_surfaces_for_output<'a>(
     output: &'a Output,
 ) -> impl Iterator<Item = &'a mut Surface> + 'a {
     kms_surfaces(state).filter(move |surface| {
-        surface.output == *output || surface.output.mirroring().as_ref() == Some(&output)
+        surface.output == *output || surface.output.mirroring().as_ref() == Some(output)
     })
 }
 
diff --git a/src/wayland/handlers/pointer_constraints.rs b/src/wayland/handlers/pointer_constraints.rs
index 27dc34337..73e7a61ab 100644
--- a/src/wayland/handlers/pointer_constraints.rs
+++ b/src/wayland/handlers/pointer_constraints.rs
@@ -16,8 +16,7 @@ impl PointerConstraintsHandler for State {
     fn new_constraint(&mut self, surface: &WlSurface, pointer: &PointerHandle<Self>) {
         // XXX region
         if pointer
-            .current_focus()
-            .map_or(false, |x| x.wl_surface().as_deref() == Some(surface))
+            .current_focus().is_some_and(|x| x.wl_surface().as_deref() == Some(surface))
         {
             with_pointer_constraint(surface, pointer, |constraint| {
                 constraint.unwrap().activate();
diff --git a/src/wayland/handlers/screencopy/mod.rs b/src/wayland/handlers/screencopy/mod.rs
index d8a026c3b..64134da0e 100644
--- a/src/wayland/handlers/screencopy/mod.rs
+++ b/src/wayland/handlers/screencopy/mod.rs
@@ -52,7 +52,7 @@ impl ScreencopyHandler for State {
                 .and_then(|output| constraints_for_output(&output, &mut self.backend)),
             ImageCaptureSourceData::Workspace(handle) => {
                 let shell = self.common.shell.read();
-                let output = shell.workspaces.space_for_handle(&handle)?.output();
+                let output = shell.workspaces.space_for_handle(handle)?.output();
                 constraints_for_output(output, &mut self.backend)
             }
             ImageCaptureSourceData::Toplevel(window) => {
@@ -339,7 +339,7 @@ fn constraints_for_output(output: &Output, backend: &mut BackendData) -> Option<
 
     let mut renderer = backend
         .offscreen_renderer(|kms| {
-            kms.target_node_for_output(&output)
+            kms.target_node_for_output(output)
                 .or(*kms.primary_node.read().unwrap())
         })
         .unwrap();
@@ -357,7 +357,7 @@ fn constraints_for_toplevel(
         .offscreen_renderer(|kms| {
             let dma_node = with_renderer_surface_state(&wl_surface, |state| {
                 let buffer = state.buffer()?;
-                let dmabuf = get_dmabuf(&*buffer).ok()?;
+                let dmabuf = get_dmabuf(buffer).ok()?;
                 dmabuf.node()
             })
             .flatten();
diff --git a/src/wayland/handlers/screencopy/render.rs b/src/wayland/handlers/screencopy/render.rs
index 5240f0e8d..4e059b54d 100644
--- a/src/wayland/handlers/screencopy/render.rs
+++ b/src/wayland/handlers/screencopy/render.rs
@@ -173,7 +173,7 @@ where
     Ok(Some(PendingImageCopyData {
         frame,
         damage: damage
-            .into_iter()
+            .iter()
             .map(|rect| {
                 let logical = rect.to_logical(1);
                 logical.to_buffer(1, transform.invert(), &buffer_size.to_logical(1, transform))
@@ -354,7 +354,7 @@ pub fn render_workspace_to_buffer(
                 &common.shell,
                 None,
                 common.clock.now(),
-                &output,
+                output,
                 None,
                 handle,
                 cursor_mode,
@@ -373,7 +373,7 @@ pub fn render_workspace_to_buffer(
                 &common.shell,
                 None,
                 common.clock.now(),
-                &output,
+                output,
                 None,
                 handle,
                 cursor_mode,
@@ -655,7 +655,7 @@ pub fn render_window_to_buffer(
                     .and_then(|wl_surface| {
                         with_renderer_surface_state(&wl_surface, |state| {
                             let buffer = state.buffer()?;
-                            let dmabuf = get_dmabuf(&*buffer).ok()?;
+                            let dmabuf = get_dmabuf(buffer).ok()?;
                             dmabuf.node()
                         })
                     })
@@ -783,7 +783,7 @@ pub fn render_cursor_to_buffer(
     {
         let mut elements = cursor::draw_cursor(
             renderer,
-            &seat,
+            seat,
             Point::from((0.0, 0.0)),
             1.0.into(),
             1.0,
diff --git a/src/wayland/handlers/security_context.rs b/src/wayland/handlers/security_context.rs
index e564f1bf6..550bd4578 100644
--- a/src/wayland/handlers/security_context.rs
+++ b/src/wayland/handlers/security_context.rs
@@ -37,14 +37,14 @@ impl SecurityContextHandler for State {
                 let drm_node = client_data
                     .as_ref()
                     .and_then(|data| data.downcast_ref::<ClientState>())
-                    .and_then(|data| data.advertised_drm_node.clone())
+                    .and_then(|data| data.advertised_drm_node)
                     .or_else(|| {
                         client_data
                             .as_ref()
                             .and_then(|data| data.downcast_ref::<XWaylandClientData>())
                             .and_then(|data| data.user_data().get::<DrmNode>().cloned())
                     })
-                    .or_else(|| new_state.advertised_drm_node.clone());
+                    .or(new_state.advertised_drm_node);
 
                 if let Err(err) = state.common.display_handle.insert_client(
                     client_stream,
diff --git a/src/wayland/handlers/session_lock.rs b/src/wayland/handlers/session_lock.rs
index 2c0e2d406..cbbbd5ac5 100644
--- a/src/wayland/handlers/session_lock.rs
+++ b/src/wayland/handlers/session_lock.rs
@@ -40,7 +40,7 @@ impl SessionLockHandler for State {
         });
 
         for output in shell.outputs() {
-            self.backend.schedule_render(&output);
+            self.backend.schedule_render(output);
         }
     }
 
@@ -49,7 +49,7 @@ impl SessionLockHandler for State {
         shell.session_lock = None;
 
         for output in shell.outputs() {
-            self.backend.schedule_render(&output);
+            self.backend.schedule_render(output);
         }
     }
 
diff --git a/src/wayland/handlers/toplevel_management.rs b/src/wayland/handlers/toplevel_management.rs
index e96edc0d5..b39864290 100644
--- a/src/wayland/handlers/toplevel_management.rs
+++ b/src/wayland/handlers/toplevel_management.rs
@@ -52,7 +52,7 @@ impl ToplevelManagementHandler for State {
             let (target, new_pos) = if let Some((idx, workspace)) = maybe {
                 let handle = workspace.handle;
                 let new_pos = shell.activate(
-                    &output,
+                    output,
                     idx,
                     WorkspaceDelta::new_shortcut(),
                     &mut self.common.workspace_state.update(),
@@ -112,7 +112,7 @@ impl ToplevelManagementHandler for State {
 
             if seat.active_output() != *output {
                 if let Some(new_pos) = new_pos {
-                    seat.set_active_output(&output);
+                    seat.set_active_output(output);
                     if let Some(ptr) = seat.get_pointer() {
                         let serial = SERIAL_COUNTER.next_serial();
                         ptr.motion(
@@ -150,7 +150,7 @@ impl ToplevelManagementHandler for State {
         let Some(surface) = window.wl_surface() else {
             return;
         };
-        let Some((from_workspace, _)) = shell.workspace_for_surface(&*surface) else {
+        let Some((from_workspace, _)) = shell.workspace_for_surface(&surface) else {
             return;
         };
 
@@ -182,7 +182,7 @@ impl ToplevelManagementHandler for State {
             .or_else(|| {
                 window
                     .wl_surface()
-                    .and_then(|surface| shell.visible_output_for_surface(&*surface).cloned())
+                    .and_then(|surface| shell.visible_output_for_surface(&surface).cloned())
             })
             .unwrap_or_else(|| seat.focused_or_active_output());
         if let Some(target) =
diff --git a/src/wayland/handlers/xdg_activation.rs b/src/wayland/handlers/xdg_activation.rs
index fa07e1913..06fbe7a5d 100644
--- a/src/wayland/handlers/xdg_activation.rs
+++ b/src/wayland/handlers/xdg_activation.rs
@@ -126,7 +126,7 @@ impl XdgActivationHandler for State {
 
                     let Some((element_output, element_workspace)) = shell
                         .space_for(&element)
-                        .map(|w| (w.output.clone(), w.handle.clone()))
+                        .map(|w| (w.output.clone(), w.handle))
                     else {
                         return;
                     };
@@ -227,7 +227,7 @@ impl XdgActivationHandler for State {
                 } else {
                     shell
                         .pending_activations
-                        .insert(ActivationKey::Wayland(surface), context.clone());
+                        .insert(ActivationKey::Wayland(surface), *context);
                 };
             }
         }
diff --git a/src/wayland/handlers/xdg_shell/mod.rs b/src/wayland/handlers/xdg_shell/mod.rs
index 667c4c311..fe4c3af90 100644
--- a/src/wayland/handlers/xdg_shell/mod.rs
+++ b/src/wayland/handlers/xdg_shell/mod.rs
@@ -99,7 +99,7 @@ impl XdgShellHandler for State {
         });
 
         if let Some(root) = maybe_root {
-            let target = root.into();
+            let target = root;
             let ret = self.common.popups.grab_popup(target, kind, &seat, serial);
             match ret {
                 Ok(mut grab) => {
@@ -304,12 +304,10 @@ impl XdgShellHandler for State {
             if should_focus {
                 Shell::set_focus(self, Some(&target), &seat, None, true);
             }
-        } else {
-            if let Some(pending) = shell.pending_windows.iter_mut().find(|pending| {
-                pending.surface.wl_surface().as_deref() == Some(surface.wl_surface())
-            }) {
-                pending.fullscreen.take();
-            }
+        } else if let Some(pending) = shell.pending_windows.iter_mut().find(|pending| {
+            pending.surface.wl_surface().as_deref() == Some(surface.wl_surface())
+        }) {
+            pending.fullscreen.take();
         }
     }
 
@@ -337,12 +335,12 @@ impl XdgShellHandler for State {
         {
             let dh = self.common.display_handle.clone();
             for client in clients.values() {
-                client_compositor_state(&client).blocker_cleared(self, &dh);
+                client_compositor_state(client).blocker_cleared(self, &dh);
             }
         }
 
         if let Some(output) = output.as_ref() {
-            self.backend.schedule_render(&output);
+            self.backend.schedule_render(output);
         }
     }
 
diff --git a/src/wayland/handlers/xdg_shell/popup.rs b/src/wayland/handlers/xdg_shell/popup.rs
index 5f9017d9d..8879600c4 100644
--- a/src/wayland/handlers/xdg_shell/popup.rs
+++ b/src/wayland/handlers/xdg_shell/popup.rs
@@ -22,7 +22,7 @@ use tracing::warn;
 
 impl Shell {
     pub fn unconstrain_popup(&self, surface: &PopupSurface) {
-        if let Some(parent) = get_popup_toplevel(&surface) {
+        if let Some(parent) = get_popup_toplevel(surface) {
             if let Some(elem) = self.element_for_surface(&parent) {
                 let (mut element_geo, output, is_tiled) =
                     if let Some(workspace) = self.space_for(elem) {
@@ -87,14 +87,14 @@ pub fn update_reactive_popups<'a>(
     for (popup, _) in PopupManager::popups_for_surface(toplevel.wl_surface()) {
         match popup {
             PopupKind::Xdg(surface) => {
-                let positioner = with_states(&surface.wl_surface(), |states| {
+                let positioner = with_states(surface.wl_surface(), |states| {
                     let attributes = states
                         .data_map
                         .get::<XdgPopupSurfaceData>()
                         .unwrap()
                         .lock()
                         .unwrap();
-                    attributes.current.positioner.clone()
+                    attributes.current.positioner
                 });
                 if positioner.reactive {
                     let anchor_point = loc + positioner.get_anchor_point().as_global();
diff --git a/src/wayland/protocols/corner_radius.rs b/src/wayland/protocols/corner_radius.rs
index e683f275a..3287ff241 100644
--- a/src/wayland/protocols/corner_radius.rs
+++ b/src/wayland/protocols/corner_radius.rs
@@ -141,11 +141,10 @@ where
                             surface.wl_surface(),
                             move |_, _dh, surface| {
                                 let corner_radii_too_big = with_states(surface, |surface_data| {
-                                    let corners = surface_data
+                                    let corners = *surface_data
                                         .cached_state
                                         .get::<CacheableCorners>()
-                                        .pending()
-                                        .clone();
+                                        .pending();
                                     surface_data
                                         .cached_state
                                         .get::<SurfaceCachedState>()
diff --git a/src/wayland/protocols/drm.rs b/src/wayland/protocols/drm.rs
index 6185db189..99c4d8535 100644
--- a/src/wayland/protocols/drm.rs
+++ b/src/wayland/protocols/drm.rs
@@ -87,7 +87,7 @@ where
     ) {
         let data = DrmInstanceData {
             formats: global_data.formats.clone(),
-            dmabuf_global: global_data.dmabuf_global.clone(),
+            dmabuf_global: global_data.dmabuf_global,
         };
         let drm_instance = data_init.init(resource, data);
 
@@ -266,7 +266,7 @@ impl<R: 'static> WlDrmState<R> {
             filter: Box::new(client_filter),
             formats,
             device_path,
-            dmabuf_global: dmabuf_global.clone(),
+            dmabuf_global: *dmabuf_global,
         };
 
         display.create_global::<D, wl_drm::WlDrm, _>(2, data)
diff --git a/src/wayland/protocols/image_capture_source.rs b/src/wayland/protocols/image_capture_source.rs
index 551c75238..3fe7e35ab 100644
--- a/src/wayland/protocols/image_capture_source.rs
+++ b/src/wayland/protocols/image_capture_source.rs
@@ -219,15 +219,12 @@ where
         _dhandle: &DisplayHandle,
         data_init: &mut DataInit<'_, D>,
     ) {
-        match request {
-            OutputSourceRequest::CreateSource { source, output } => {
-                let data = match Output::from_resource(&output) {
-                    Some(output) => ImageCaptureSourceData::Output(output.downgrade()),
-                    None => ImageCaptureSourceData::Destroyed,
-                };
-                data_init.init(source, data);
-            }
-            _ => {}
+        if let OutputSourceRequest::CreateSource { source, output } = request {
+            let data = match Output::from_resource(&output) {
+                Some(output) => ImageCaptureSourceData::Output(output.downgrade()),
+                None => ImageCaptureSourceData::Destroyed,
+            };
+            data_init.init(source, data);
         }
     }
 
@@ -256,15 +253,12 @@ where
         _dhandle: &DisplayHandle,
         data_init: &mut DataInit<'_, D>,
     ) {
-        match request {
-            CosmicWorkspaceSourceRequest::CreateSource { source, output } => {
-                let data = match state.workspace_state().get_ext_workspace_handle(&output) {
-                    Some(workspace) => ImageCaptureSourceData::Workspace(workspace),
-                    None => ImageCaptureSourceData::Destroyed,
-                };
-                data_init.init(source, data);
-            }
-            _ => {}
+        if let CosmicWorkspaceSourceRequest::CreateSource { source, output } = request {
+            let data = match state.workspace_state().get_ext_workspace_handle(&output) {
+                Some(workspace) => ImageCaptureSourceData::Workspace(workspace),
+                None => ImageCaptureSourceData::Destroyed,
+            };
+            data_init.init(source, data);
         }
     }
 
@@ -293,18 +287,15 @@ where
         _dhandle: &DisplayHandle,
         data_init: &mut DataInit<'_, D>,
     ) {
-        match request {
-            ToplevelSourceRequest::CreateSource {
+        if let ToplevelSourceRequest::CreateSource {
                 source,
                 toplevel_handle,
-            } => {
-                let data = match window_from_ext_handle(state, &toplevel_handle) {
-                    Some(toplevel) => ImageCaptureSourceData::Toplevel(toplevel.clone()),
-                    None => ImageCaptureSourceData::Destroyed,
-                };
-                data_init.init(source, data);
-            }
-            _ => {}
+            } = request {
+            let data = match window_from_ext_handle(state, &toplevel_handle) {
+                Some(toplevel) => ImageCaptureSourceData::Toplevel(toplevel.clone()),
+                None => ImageCaptureSourceData::Destroyed,
+            };
+            data_init.init(source, data);
         }
     }
 
@@ -330,9 +321,7 @@ where
         _dhandle: &DisplayHandle,
         _data_init: &mut DataInit<'_, D>,
     ) {
-        match request {
-            _ => {}
-        }
+        {}
     }
 
     fn destroyed(
diff --git a/src/wayland/protocols/output_configuration/handlers/cosmic.rs b/src/wayland/protocols/output_configuration/handlers/cosmic.rs
index 736d75b0e..919baedf9 100644
--- a/src/wayland/protocols/output_configuration/handlers/cosmic.rs
+++ b/src/wayland/protocols/output_configuration/handlers/cosmic.rs
@@ -148,19 +148,16 @@ where
         _dh: &DisplayHandle,
         _data_init: &mut DataInit<'_, D>,
     ) {
-        match request {
-            zcosmic_output_head_v1::Request::Release => {
-                let inner = state.output_configuration_state();
-                if let Some(head) = inner
-                    .instances
-                    .iter_mut()
-                    .flat_map(|instance| instance.heads.iter_mut())
-                    .find(|head| head.extension_obj.as_ref().is_some_and(|o| o == obj))
-                {
-                    head.extension_obj.take();
-                }
+        if let zcosmic_output_head_v1::Request::Release = request {
+            let inner = state.output_configuration_state();
+            if let Some(head) = inner
+                .instances
+                .iter_mut()
+                .flat_map(|instance| instance.heads.iter_mut())
+                .find(|head| head.extension_obj.as_ref().is_some_and(|o| o == obj))
+            {
+                head.extension_obj.take();
             }
-            _ => {}
         }
     }
 }
diff --git a/src/wayland/protocols/output_configuration/handlers/wlr.rs b/src/wayland/protocols/output_configuration/handlers/wlr.rs
index 4666b1148..75d75a06c 100644
--- a/src/wayland/protocols/output_configuration/handlers/wlr.rs
+++ b/src/wayland/protocols/output_configuration/handlers/wlr.rs
@@ -136,13 +136,10 @@ where
         _dh: &DisplayHandle,
         _data_init: &mut DataInit<'_, D>,
     ) {
-        match request {
-            zwlr_output_head_v1::Request::Release => {
-                for instance in &mut state.output_configuration_state().instances {
-                    instance.heads.retain(|h| &h.obj != obj);
-                }
+        if let zwlr_output_head_v1::Request::Release = request {
+            for instance in &mut state.output_configuration_state().instances {
+                instance.heads.retain(|h| &h.obj != obj);
             }
-            _ => {}
         }
     }
 
@@ -173,16 +170,13 @@ where
         _dh: &DisplayHandle,
         _data_init: &mut DataInit<'_, D>,
     ) {
-        match request {
-            zwlr_output_mode_v1::Request::Release => {
-                let state = state.output_configuration_state();
-                for instance in &mut state.instances {
-                    for head in &mut instance.heads {
-                        head.modes.retain(|mode| mode != obj)
-                    }
+        if let zwlr_output_mode_v1::Request::Release = request {
+            let state = state.output_configuration_state();
+            for instance in &mut state.instances {
+                for head in &mut instance.heads {
+                    head.modes.retain(|mode| mode != obj)
                 }
             }
-            _ => {}
         }
     }
 }
@@ -281,13 +275,11 @@ where
                     .heads
                     .iter_mut()
                     .map(|(head, conf)| {
-                        let output = match {
-                            inner
-                                .instances
-                                .iter()
-                                .find_map(|instance| instance.heads.iter().find(|h| h.obj == *head))
-                                .map(|i| i.output.clone())
-                        } {
+                        let output = match inner
+                        .instances
+                        .iter()
+                        .find_map(|instance| instance.heads.iter().find(|h| h.obj == *head))
+                        .map(|i| i.output.clone()) {
                             Some(o) => o,
                             None => {
                                 return Err(zwlr_output_configuration_head_v1::Error::InvalidMode);
diff --git a/src/wayland/protocols/output_configuration/mod.rs b/src/wayland/protocols/output_configuration/mod.rs
index a29bfa8bb..98b2b2b1f 100644
--- a/src/wayland/protocols/output_configuration/mod.rs
+++ b/src/wayland/protocols/output_configuration/mod.rs
@@ -37,8 +37,7 @@ mod handlers;
 pub fn head_is_enabled(output: &Output) -> bool {
     output
         .user_data()
-        .get::<OutputState>()
-        .map_or(false, |inner| inner.lock().unwrap().enabled)
+        .get::<OutputState>().is_some_and(|inner| inner.lock().unwrap().enabled)
 }
 
 #[derive(Debug)]
@@ -135,7 +134,7 @@ impl<'a> TryFrom<&'a mut PendingOutputConfigurationInner> for OutputConfiguratio
                 wlr_mode
                     .data::<Mode>()
                     .cloned()
-                    .ok_or_else(|| zwlr_output_configuration_head_v1::Error::InvalidMode)?,
+                    .ok_or(zwlr_output_configuration_head_v1::Error::InvalidMode)?,
             )),
             Some(ModeConfiguration::Custom { size, refresh }) => {
                 Some(ModeConfiguration::Custom { size, refresh })
@@ -283,7 +282,7 @@ where
             for instance in &mut self.instances {
                 let mut removed_heads = Vec::new();
                 for head in &mut instance.heads {
-                    if &head.output == &output {
+                    if head.output == output {
                         if head.obj.version() < zwlr_output_head_v1::REQ_RELEASE_SINCE {
                             removed_heads.push(head.obj.clone());
                         }
@@ -435,7 +434,7 @@ where
                     .map(|c| c == output_mode)
                     .unwrap_or(false)
             {
-                instance.obj.current_mode(&*mode);
+                instance.obj.current_mode(mode);
             }
         }
     }
diff --git a/src/wayland/protocols/overlap_notify.rs b/src/wayland/protocols/overlap_notify.rs
index 22a4b7650..1310b5ebd 100644
--- a/src/wayland/protocols/overlap_notify.rs
+++ b/src/wayland/protocols/overlap_notify.rs
@@ -120,7 +120,7 @@ impl OverlapNotifyState {
 
                                     w.is_sticky()
                                         || active_workspaces.iter().any(|active_workspace| {
-                                            state.in_workspace(&active_workspace)
+                                            state.in_workspace(active_workspace)
                                         })
                                 })
                         {
@@ -208,8 +208,8 @@ impl LayerOverlapNotificationDataInternal {
                 }
             }
         }
-        for (_, (identifier, namespace, exclusive, layer, overlap)) in
-            &self.last_snapshot.layer_overlaps
+        for (identifier, namespace, exclusive, layer, overlap) in
+            self.last_snapshot.layer_overlaps.values()
         {
             new_notification.layer_enter(
                 identifier.clone(),
@@ -414,22 +414,19 @@ where
         _dhandle: &DisplayHandle,
         data_init: &mut smithay::reexports::wayland_server::DataInit<'_, D>,
     ) {
-        match request {
-            zcosmic_overlap_notify_v1::Request::NotifyOnOverlap {
+        if let zcosmic_overlap_notify_v1::Request::NotifyOnOverlap {
                 overlap_notification,
                 layer_surface,
-            } => {
-                let notification = data_init.init(overlap_notification, ());
-                if let Some(surface) = state.layer_surface_from_resource(layer_surface) {
-                    let mut data = surface
-                        .user_data()
-                        .get_or_insert_threadsafe(LayerOverlapNotificationData::default)
-                        .lock()
-                        .unwrap();
-                    data.add_notification(notification);
-                }
+            } = request {
+            let notification = data_init.init(overlap_notification, ());
+            if let Some(surface) = state.layer_surface_from_resource(layer_surface) {
+                let mut data = surface
+                    .user_data()
+                    .get_or_insert_threadsafe(LayerOverlapNotificationData::default)
+                    .lock()
+                    .unwrap();
+                data.add_notification(notification);
             }
-            _ => {}
         }
     }
 
@@ -461,9 +458,7 @@ where
         _dhandle: &DisplayHandle,
         _data_init: &mut smithay::reexports::wayland_server::DataInit<'_, D>,
     ) {
-        match request {
-            _ => {}
-        }
+        {}
     }
 }
 
diff --git a/src/wayland/protocols/screencopy.rs b/src/wayland/protocols/screencopy.rs
index 85669d053..a53f59c03 100644
--- a/src/wayland/protocols/screencopy.rs
+++ b/src/wayland/protocols/screencopy.rs
@@ -167,7 +167,7 @@ impl SessionRef {
     }
 
     pub fn user_data(&self) -> &UserDataMap {
-        &*self.user_data
+        &self.user_data
     }
 }
 
@@ -346,7 +346,7 @@ impl CursorSessionRef {
     }
 
     pub fn user_data(&self) -> &UserDataMap {
-        &*self.user_data
+        &self.user_data
     }
 }
 
@@ -746,25 +746,22 @@ where
         _dhandle: &DisplayHandle,
         data_init: &mut DataInit<'_, D>,
     ) {
-        match request {
-            ext_image_copy_capture_session_v1::Request::CreateFrame { frame } => {
-                let inner = Arc::new(Mutex::new(FrameInner::new(
-                    resource.clone(),
-                    data.inner.lock().unwrap().constraints.clone(),
-                )));
-                let obj = data_init.init(
-                    frame,
-                    FrameData {
-                        inner: inner.clone(),
-                    },
-                );
-                data.inner
-                    .lock()
-                    .unwrap()
-                    .active_frames
-                    .push(FrameRef { obj, inner });
-            }
-            _ => {}
+        if let ext_image_copy_capture_session_v1::Request::CreateFrame { frame } = request {
+            let inner = Arc::new(Mutex::new(FrameInner::new(
+                resource.clone(),
+                data.inner.lock().unwrap().constraints.clone(),
+            )));
+            let obj = data_init.init(
+                frame,
+                FrameData {
+                    inner: inner.clone(),
+                },
+            );
+            data.inner
+                .lock()
+                .unwrap()
+                .active_frames
+                .push(FrameRef { obj, inner });
         }
     }
 
@@ -803,45 +800,42 @@ where
         _dhandle: &DisplayHandle,
         data_init: &mut DataInit<'_, D>,
     ) {
-        match request {
-            ext_image_copy_capture_cursor_session_v1::Request::GetCaptureSession { session } => {
-                let new_data = CursorSessionData {
-                    inner: data.inner.clone(),
-                };
-                let session = data_init.init(session, new_data);
+        if let ext_image_copy_capture_cursor_session_v1::Request::GetCaptureSession { session } = request {
+            let new_data = CursorSessionData {
+                inner: data.inner.clone(),
+            };
+            let session = data_init.init(session, new_data);
+
+            let mut inner = data.inner.lock().unwrap();
+            if inner.session.is_some() {
+                resource.post_error(
+                    ext_image_copy_capture_cursor_session_v1::Error::DuplicateSession,
+                    "Duplicate session",
+                );
+                return;
+            }
 
-                let mut inner = data.inner.lock().unwrap();
-                if inner.session.is_some() {
-                    resource.post_error(
-                        ext_image_copy_capture_cursor_session_v1::Error::DuplicateSession,
-                        "Duplicate session",
-                    );
-                    return;
+            if inner.stopped {
+                session.stopped();
+            } else if let Some(constraints) = inner.constraints.as_ref() {
+                session.buffer_size(constraints.size.w as u32, constraints.size.h as u32);
+                for fmt in &constraints.shm {
+                    session.shm_format(*fmt);
                 }
-
-                if inner.stopped {
-                    session.stopped();
-                } else if let Some(constraints) = inner.constraints.as_ref() {
-                    session.buffer_size(constraints.size.w as u32, constraints.size.h as u32);
-                    for fmt in &constraints.shm {
-                        session.shm_format(*fmt);
-                    }
-                    if let Some(dma) = constraints.dma.as_ref() {
-                        let node = Vec::from(dma.node.dev_id().to_ne_bytes());
-                        session.dmabuf_device(node);
-                        for (fmt, modifiers) in &dma.formats {
-                            let modifiers = modifiers
-                                .iter()
-                                .flat_map(|modifier| u64::from(*modifier).to_ne_bytes())
-                                .collect::<Vec<u8>>();
-                            session.dmabuf_format(*fmt as u32, modifiers);
-                        }
+                if let Some(dma) = constraints.dma.as_ref() {
+                    let node = Vec::from(dma.node.dev_id().to_ne_bytes());
+                    session.dmabuf_device(node);
+                    for (fmt, modifiers) in &dma.formats {
+                        let modifiers = modifiers
+                            .iter()
+                            .flat_map(|modifier| u64::from(*modifier).to_ne_bytes())
+                            .collect::<Vec<u8>>();
+                        session.dmabuf_format(*fmt as u32, modifiers);
                     }
-                    session.done();
                 }
-                inner.session = Some(session);
+                session.done();
             }
-            _ => {}
+            inner.session = Some(session);
         }
     }
 
@@ -879,25 +873,22 @@ where
         _dhandle: &DisplayHandle,
         data_init: &mut DataInit<'_, D>,
     ) {
-        match request {
-            ext_image_copy_capture_session_v1::Request::CreateFrame { frame } => {
-                let inner = Arc::new(Mutex::new(FrameInner::new(
-                    resource.clone(),
-                    data.inner.lock().unwrap().constraints.clone(),
-                )));
-                let obj = data_init.init(
-                    frame,
-                    FrameData {
-                        inner: inner.clone(),
-                    },
-                );
-                data.inner
-                    .lock()
-                    .unwrap()
-                    .active_frames
-                    .push(FrameRef { obj, inner });
-            }
-            _ => {}
+        if let ext_image_copy_capture_session_v1::Request::CreateFrame { frame } = request {
+            let inner = Arc::new(Mutex::new(FrameInner::new(
+                resource.clone(),
+                data.inner.lock().unwrap().constraints.clone(),
+            )));
+            let obj = data_init.init(
+                frame,
+                FrameData {
+                    inner: inner.clone(),
+                },
+            );
+            data.inner
+                .lock()
+                .unwrap()
+                .active_frames
+                .push(FrameRef { obj, inner });
         }
     }
 
diff --git a/src/wayland/protocols/toplevel_info.rs b/src/wayland/protocols/toplevel_info.rs
index 45557959c..c9a9735a9 100644
--- a/src/wayland/protocols/toplevel_info.rs
+++ b/src/wayland/protocols/toplevel_info.rs
@@ -252,10 +252,7 @@ where
         _dh: &DisplayHandle,
         _data_init: &mut DataInit<'_, D>,
     ) {
-        match request {
-            zcosmic_toplevel_handle_v1::Request::Destroy => {}
-            _ => {}
-        }
+        if let zcosmic_toplevel_handle_v1::Request::Destroy = request {}
     }
 
     fn destroyed(
@@ -290,7 +287,7 @@ pub fn toplevel_leave_output(toplevel: &impl Window, output: &Output) {
 
 pub fn toplevel_enter_workspace(toplevel: &impl Window, workspace: &WorkspaceHandle) {
     if let Some(state) = toplevel.user_data().get::<ToplevelState>() {
-        state.lock().unwrap().workspaces.push(workspace.clone());
+        state.lock().unwrap().workspaces.push(*workspace);
     }
 }
 
@@ -509,7 +506,7 @@ where
         changed = true;
     }
 
-    if handle_state.states.as_ref().map_or(true, |states| {
+    if handle_state.states.as_ref().is_none_or(|states| {
         (states.contains(&States::Maximized) != window.is_maximized())
             || (states.contains(&States::Fullscreen) != window.is_fullscreen())
             || (states.contains(&States::Activated) != window.is_activated())
@@ -562,7 +559,7 @@ where
                 .geometry
                 .filter(|_| instance.version() >= zcosmic_toplevel_handle_v1::EVT_GEOMETRY_SINCE)
                 .filter(|geo| output.geometry().intersection(*geo).is_some())
-                .map(|geo| geo.to_local(&output));
+                .map(|geo| geo.to_local(output));
             for wl_output in output.client_outputs(&client) {
                 if handle_state.wl_outputs.insert(wl_output.clone()) {
                     instance.output_enter(&wl_output);
@@ -584,7 +581,7 @@ where
                     .iter()
                     .any(|output| output.owns(wl_output));
             if !retain {
-                instance.output_leave(&wl_output);
+                instance.output_leave(wl_output);
                 changed = true;
             }
             retain
@@ -596,8 +593,8 @@ where
         .iter()
         .filter(|w| !handle_state.workspaces.contains(w))
     {
-        for handle in workspace_state.raw_ext_workspace_handles(&new_workspace, &instance.id()) {
-            instance.ext_workspace_enter(&handle);
+        for handle in workspace_state.raw_ext_workspace_handles(new_workspace, &instance.id()) {
+            instance.ext_workspace_enter(handle);
             changed = true;
         }
     }
@@ -606,8 +603,8 @@ where
         .iter()
         .filter(|w| !state.workspaces.contains(w))
     {
-        for handle in workspace_state.raw_ext_workspace_handles(&old_workspace, &instance.id()) {
-            instance.ext_workspace_leave(&handle);
+        for handle in workspace_state.raw_ext_workspace_handles(old_workspace, &instance.id()) {
+            instance.ext_workspace_leave(handle);
             changed = true;
         }
     }
diff --git a/src/wayland/protocols/workspace/ext.rs b/src/wayland/protocols/workspace/ext.rs
index 3599ddba2..bd0de973f 100644
--- a/src/wayland/protocols/workspace/ext.rs
+++ b/src/wayland/protocols/workspace/ext.rs
@@ -350,7 +350,7 @@ where
             let retain =
                 wl_output.is_alive() && group.outputs.iter().any(|output| output.owns(wl_output));
             if !retain {
-                instance.output_leave(&wl_output);
+                instance.output_leave(wl_output);
                 changed = true;
             }
             retain
@@ -361,7 +361,7 @@ where
 
     if handle_state.capabilities != Some(group.capabilities) {
         instance.capabilities(group.capabilities);
-        handle_state.capabilities = Some(group.capabilities.clone());
+        handle_state.capabilities = Some(group.capabilities);
         changed = true;
     }
 
diff --git a/src/wayland/protocols/workspace/mod.rs b/src/wayland/protocols/workspace/mod.rs
index dc348cc85..5841a6cbd 100644
--- a/src/wayland/protocols/workspace/mod.rs
+++ b/src/wayland/protocols/workspace/mod.rs
@@ -305,8 +305,8 @@ where
     fn done(&mut self) {
         let mut changed = false;
         for instance in &self.ext_instances {
-            for mut group in &mut self.groups {
-                if ext::send_group_to_client::<D>(&self.dh, instance, &mut group) {
+            for group in &mut self.groups {
+                if ext::send_group_to_client::<D>(&self.dh, instance, group) {
                     changed = true;
                 }
             }
@@ -338,7 +338,7 @@ where
     }
 }
 
-impl<'a, D> WorkspaceUpdateGuard<'a, D>
+impl<D> WorkspaceUpdateGuard<'_, D>
 where
     D: WorkspaceHandler,
 {
@@ -617,7 +617,7 @@ where
     }
 }
 
-impl<'a, D> Drop for WorkspaceUpdateGuard<'a, D>
+impl<D> Drop for WorkspaceUpdateGuard<'_, D>
 where
     D: WorkspaceHandler,
 {
diff --git a/src/xwayland.rs b/src/xwayland.rs
index 2a131c096..358607786 100644
--- a/src/xwayland.rs
+++ b/src/xwayland.rs
@@ -143,7 +143,6 @@ impl State {
             Err(err) => {
                 error!(?err, "Failed to listen for Xwayland");
                 self.notify_ready();
-                return;
             }
         }
     }
@@ -188,7 +187,7 @@ fn scale_cursor(
         &[Rectangle::new((0, 0).into(), output_size)],
     )?;
     let sync = frame.finish()?;
-    while let Err(_) = sync.wait() {}
+    while sync.wait().is_err() {}
 
     let len = (buffer_size.w * buffer_size.h * 4) as usize;
     let mut data = Vec::with_capacity(len);
@@ -750,7 +749,7 @@ impl XwmHandler for State {
         {
             shell.pending_activations.insert(
                 crate::shell::ActivationKey::X11(window.window_id()),
-                context.clone(),
+                *context,
             );
         }
 
@@ -771,10 +770,8 @@ impl XwmHandler for State {
             .find(|pending| pending.surface.x11_surface() == Some(&surface))
             .map(|pending| pending.surface.clone())
         {
-            if !shell
-                .pending_activations
-                .contains_key(&crate::shell::ActivationKey::X11(surface.window_id()))
-            {
+            if let std::collections::hash_map::Entry::Vacant(e) = shell
+                .pending_activations.entry(crate::shell::ActivationKey::X11(surface.window_id())) {
                 if let Some(startup_id) = window.x11_surface().and_then(|x| x.startup_id()) {
                     if let Some(context) = self
                         .common
@@ -782,10 +779,7 @@ impl XwmHandler for State {
                         .data_for_token(&XdgActivationToken::from(startup_id))
                         .and_then(|data| data.user_data.get::<ActivationContext>())
                     {
-                        shell.pending_activations.insert(
-                            crate::shell::ActivationKey::X11(surface.window_id()),
-                            context.clone(),
-                        );
+                        e.insert(*context);
                     }
                 }
             }
@@ -875,7 +869,7 @@ impl XwmHandler for State {
                     set.sticky_layer
                         .element_geometry(mapped)
                         .unwrap()
-                        .to_global(&output),
+                        .to_global(output),
                 )
             } else {
                 None
@@ -1100,14 +1094,12 @@ impl XwmHandler for State {
             if should_focus {
                 Shell::set_focus(self, Some(&target), &seat, None, true);
             }
-        } else {
-            if let Some(pending) = shell
-                .pending_windows
-                .iter_mut()
-                .find(|pending| pending.surface.x11_surface() == Some(&window))
-            {
-                pending.fullscreen.take();
-            }
+        } else if let Some(pending) = shell
+            .pending_windows
+            .iter_mut()
+            .find(|pending| pending.surface.x11_surface() == Some(&window))
+        {
+            pending.fullscreen.take();
         }
     }
 
